\section{Desarrollo de la Solución}

\subsection{Metodología Scrum Aplicada}

El desarrollo de Irakani Builder se ejecutó siguiendo la metodología ágil Scrum, con sprints de 2 semanas de duración cada uno. Esta metodología permitió iteraciones rápidas, retroalimentación continua y adaptación a los cambios en los requerimientos del negocio.

\textbf{Nota sobre el Cronograma:} El proyecto se planificó para ejecutarse desde julio hasta diciembre de 2025, con un período total de 6 meses distribuidos en 11 sprints. La planificación detallada se realizó durante la fase de concepción del proyecto, estableciendo fechas objetivo para cada entregable y permitiendo ajustes según la velocidad real del equipo durante la ejecución.

\subsubsection{Roles del Equipo}

El equipo Scrum estuvo conformado por los siguientes roles:

\begin{itemize}
    \item \textbf{Product Owner:} Luis Flores - Responsable de definir y priorizar el Product Backlog según el valor de negocio
    \item \textbf{Scrum Master / Desarrollador:} Angel Mariscal - Facilitador del proceso Scrum y desarrollador principal
    \item \textbf{Stakeholders:} Equipo de Proyectos de Irakani - Usuarios finales que proporcionaron retroalimentación continua
\end{itemize}

\subsubsection{Duración y Estructura de Sprints}

El proyecto se planificó en 11 sprints con una duración de 2 semanas cada uno (excepto el Sprint 11 de cierre con 5 días), abarcando un período total de 6 meses desde julio hasta diciembre de 2025. La Tabla \ref{tab:sprints_planificacion} muestra la planificación completa de sprints:

\begin{table}[H]
\centering
\caption{Planificación de Sprints del Proyecto Irakani Builder}
\label{tab:sprints_planificacion}
\begin{tabular}{|l|l|c|c|}
\hline
\textbf{Sprint} & \textbf{Épica Principal} & \textbf{Inicio} & \textbf{Fin} \\
\hline
Sprint 0 & Concepción y Diseño & 14/07/2025 & 27/07/2025 \\
\hline
Sprint 1 & Autenticación y Seguridad & 28/07/2025 & 10/08/2025 \\
\hline
Sprint 2 & Núcleo de IA & 11/08/2025 & 24/08/2025 \\
\hline
Sprint 3 & Interfaz Base & 25/08/2025 & 07/09/2025 \\
\hline
Sprint 4 & Editor Visual & 08/09/2025 & 21/09/2025 \\
\hline
Sprint 5 & Renderizado y Bases de Datos & 22/09/2025 & 05/10/2025 \\
\hline
Sprint 6 & Gestión de Datos Avanzada & 06/10/2025 & 19/10/2025 \\
\hline
Sprint 7 & Asistente de Chat y Sesiones & 20/10/2025 & 02/11/2025 \\
\hline
Sprint 8 & Gestión de Componentes & 03/11/2025 & 16/11/2025 \\
\hline
Sprint 9 & Personalización & 17/11/2025 & 30/11/2025 \\
\hline
Sprint 10 & Despliegue y Validación Final & 01/12/2025 & 14/12/2025 \\
\hline
Sprint 11 & Buffer y Cierre & 15/12/2025 & 19/12/2025 \\
\hline
\end{tabular}
\end{table}

\subsubsection{Ceremonias Implementadas}

Durante cada sprint se realizaron las siguientes ceremonias Scrum:

\begin{itemize}
    \item \textbf{Sprint Planning:} Reunión al inicio de cada sprint para seleccionar historias de usuario del Product Backlog y definir el Sprint Goal
    \item \textbf{Daily Standup:} Reuniones diarias de 15 minutos para sincronización del equipo (adaptadas al contexto de equipo reducido)
    \item \textbf{Sprint Review:} Demostración de funcionalidades completadas al Product Owner y stakeholders al final de cada sprint
    \item \textbf{Sprint Retrospective:} Reflexión sobre el proceso y definición de mejoras para el siguiente sprint
    \item \textbf{Backlog Refinement:} Sesiones continuas para refinar y estimar historias de usuario futuras
\end{itemize}

\subsection{Conformación del Product Backlog}

\subsubsection{Épicas del Proyecto}

El Product Backlog se organizó en 11 épicas principales que agrupan las historias de usuario por funcionalidad y alineadas con cada sprint. Cada épica representa un conjunto cohesivo de funcionalidades que aportan valor incremental al producto:

\begin{enumerate}
    \item \textbf{Épica 1 - Sprint 0: Concepción y Diseño}
    \begin{itemize}
        \item Configuración del entorno de desarrollo
        \item Definición de arquitectura de microservicios
        \item Establecimiento de estándares de código y documentación
    \end{itemize}
    
    \item \textbf{Épica 2 - Sprint 1: Autenticación y Seguridad}
    \begin{itemize}
        \item Sistema de autenticación con JWT
        \item Integración con AWS Cognito
        \item Gestión de sesiones seguras
    \end{itemize}
    
    \item \textbf{Épica 3 - Sprint 2: Núcleo de IA}
    \begin{itemize}
        \item Integración con AWS Bedrock
        \item Ingeniería de prompts para generación de componentes
        \item Optimización de llamadas a modelos de IA
    \end{itemize}
    
    \item \textbf{Épica 4 - Sprint 3: Interfaz Base}
    \begin{itemize}
        \item Desarrollo de interfaz con React 18
        \item Sistema de navegación y routing
        \item Componentes base reutilizables
    \end{itemize}
    
    \item \textbf{Épica 5 - Sprint 4: Editor Visual}
    \begin{itemize}
        \item Editor visual de formularios
        \item Integración de Monaco Editor
        \item Panel de propiedades contextual
    \end{itemize}
    
    \item \textbf{Épica 6 - Sprint 5: Renderizado y Bases de Datos}
    \begin{itemize}
        \item Transformación JSON a componentes visuales
        \item Conexión multi-motor de bases de datos
        \item Pool de conexiones optimizado
    \end{itemize}
    
    \item \textbf{Épica 7 - Sprint 6: Gestión de Datos Avanzada}
    \begin{itemize}
        \item Administrador de base de datos con IA
        \item Generación de queries desde lenguaje natural
        \item Explorador de esquemas de base de datos
    \end{itemize}
    
    \item \textbf{Épica 8 - Sprint 7: Asistente de Chat y Sesiones}
    \begin{itemize}
        \item Chat de asistencia con IA
        \item Sistema de guardado y recuperación de sesiones
        \item Gestión de múltiples sesiones simultáneas
    \end{itemize}
    
    \item \textbf{Épica 9 - Sprint 8: Gestión de Componentes}
    \begin{itemize}
        \item Listado y organización de aplicaciones
        \item Operaciones CRUD sobre componentes
        \item Versionamiento de aplicaciones
    \end{itemize}
    
    \item \textbf{Épica 10 - Sprint 9: Personalización}
    \begin{itemize}
        \item Sistema de temas personalizable
        \item Configuración de preferencias de usuario
        \item Más de 20 temas predefinidos
    \end{itemize}
    
    \item \textbf{Épica 11 - Sprint 10: Despliegue y Validación Final}
    \begin{itemize}
        \item Pipeline CI/CD completo
        \item Despliegue en producción
        \item Pruebas de integración final
        \item Monitoreo y observabilidad
    \end{itemize}
    
    \item \textbf{Épica 12 - Sprint 11: Buffer y Cierre}
    \begin{itemize}
        \item Resolución de deuda técnica
        \item Documentación final
        \item Preparación de entrega
    \end{itemize}
\end{enumerate}

\subsubsection{Identificación de Historias de Usuario (Requerimientos funcionales)}

Las siguientes historias de usuario fueron identificadas y estructuradas siguiendo el formato estándar de Scrum: ``Como [rol], quiero [funcionalidad], para [beneficio]''. Cada historia incluye criterios de aceptación medibles que definen cuándo se considera completada según la Definition of Done (DoD).

Las historias se organizan por épica, alineadas con la planificación de sprints del proyecto.

\vspace{0.5cm}

\textbf{Épica 1: Sprint 0 - Concepción y Diseño}

\vspace{0.3cm}

\textbf{HU-001: Configuración del Entorno de Desarrollo}

\begin{itemize}
    \item \textbf{Como} desarrollador del equipo de Plataforma
    \item \textbf{Quiero} tener un repositorio Git configurado con flujos CI/CD automatizados
    \item \textbf{Para} garantizar la integración continua y el despliegue automatizado del código
\end{itemize}

\textbf{Criterios de Aceptación:}
\begin{itemize}
    \item Repositorio creado en Bitbucket con estructura de carpetas definida
    \item Pipeline CI/CD configurado para compilación automática
    \item Pruebas automatizadas ejecutándose en cada commit
    \item Documentación del flujo de trabajo en README.md
\end{itemize}

\textbf{Prioridad:} Crítica | \textbf{Story Points:} 5 | \textbf{Sprint:} Sprint 0

\vspace{0.5cm}

\textbf{HU-002: Definición de Arquitectura de Microservicios}

\begin{itemize}
    \item \textbf{Como} arquitecto de software
    \item \textbf{Quiero} diseñar una arquitectura basada en microservicios con APIs RESTful
    \item \textbf{Para} evitar la deuda técnica y garantizar escalabilidad
\end{itemize}

\textbf{Criterios de Aceptación:}
\begin{itemize}
    \item Diagrama de arquitectura documentado (frontend, backend, servicios)
    \item Definición de endpoints RESTful principales
    \item Especificación de comunicación entre servicios
    \item Stack tecnológico validado (React 18, Node.js, AWS Bedrock)
\end{itemize}

\textbf{Prioridad:} Crítica | \textbf{Story Points:} 8 | \textbf{Sprint:} Sprint 0

\vspace{0.5cm}

\textbf{Épica 2: Sprint 1 - Autenticación y Seguridad}

\vspace{0.3cm}

\textbf{HU-003: Sistema de Autenticación con JWT}

\begin{itemize}
    \item \textbf{Como} usuario del equipo de Proyectos
    \item \textbf{Quiero} poder iniciar sesión de forma segura en la plataforma
    \item \textbf{Para} acceder a las funcionalidades del Builder de manera protegida
\end{itemize}

\textbf{Criterios de Aceptación:}
\begin{itemize}
    \item Endpoint /api/auth/login funcional con validación de credenciales
    \item Generación de tokens JWT con expiración configurable
    \item Middleware de autenticación implementado en Node.js
    \item Manejo de errores (credenciales inválidas, token expirado)
    \item Pruebas unitarias con cobertura >80\%
\end{itemize}

\textbf{Prioridad:} Alta | \textbf{Story Points:} 8 | \textbf{Sprint:} Sprint 1

\vspace{0.5cm}

\textbf{Épica 3: Sprint 2 - Núcleo de IA}

\vspace{0.3cm}

\textbf{HU-004: Integración con AWS Bedrock}

\begin{itemize}
    \item \textbf{Como} desarrollador
    \item \textbf{Quiero} conectar la plataforma con AWS Bedrock
    \item \textbf{Para} habilitar la generación de código asistida por IA
\end{itemize}

\textbf{Criterios de Aceptación:}
\begin{itemize}
    \item Cliente de AWS Bedrock configurado en Node.js
    \item Endpoint /api/ai/generate funcional
    \item Manejo de errores de API (timeout, rate limit, errores del modelo)
    \item Logs de uso y latencia de llamadas a Bedrock
    \item Pruebas de integración exitosas
\end{itemize}

\textbf{Prioridad:} Crítica | \textbf{Story Points:} 13 | \textbf{Sprint:} Sprint 2


\vspace{0.5cm}

\textbf{HU-005: Ingeniería de Prompts para Generación y Edición de Componentes}

\begin{itemize}
    \item \textbf{Como} Product Owner
    \item \textbf{Quiero} que la IA genere estructuras JSON válidas a partir de descripciones en lenguaje natural
    \item \textbf{Para} automatizar la creación y edición de componentes
\end{itemize}

\textbf{Criterios de Aceptación:}
\begin{itemize}
    \item Meta-prompts diseñados con técnicas Few-shot y Chain-of-Thought
    \item Validación de esquema JSON de salida
    \item Tasa de éxito >85\% en generación de estructuras válidas
    \item Documentación de patrones de prompts efectivos
    \item Casos de prueba: formulario de registro, encuesta, visita
\end{itemize}

\textbf{Prioridad:} Crítica | \textbf{Story Points:} 13 | \textbf{Sprint:} Sprint 2

\vspace{0.5cm}

\textbf{Épica 4: Sprint 3 - Interfaz Base}

\vspace{0.3cm}

\textbf{HU-006: Interfaz de Usuario con React 18}

\begin{itemize}
    \item \textbf{Como} usuario
    \item \textbf{Quiero} una interfaz moderna y responsiva
    \item \textbf{Para} trabajar cómodamente en cualquier dispositivo
\end{itemize}

\textbf{Criterios de Aceptación:}
\begin{itemize}
    \item Componentes React con TypeScript implementados
    \item Diseño responsivo
    \item Sistema de temas personalizable (>20 temas)
    \item Navegación fluida entre secciones
\end{itemize}

\textbf{Prioridad:} Alta | \textbf{Story Points:} 13 | \textbf{Sprint:} Sprint 3

\vspace{0.5cm}

\textbf{Épica 5: Sprint 4 - Editor Visual}

\vspace{0.3cm}

\textbf{HU-007: Editor Visual}

\begin{itemize}
    \item \textbf{Como} desarrollador
    \item \textbf{Quiero} seleccionar componentes visuales para diseñar componentes
    \item \textbf{Para} acelerar el proceso de prototipado
\end{itemize}

\textbf{Criterios de Aceptación:}
\begin{itemize}
    \item Paleta de componentes (formularios, botones, campos, etc.)
    \item Funcionalidad de selección operativa
    \item Panel de propiedades para configurar componentes
    \item Actualización en tiempo real de la vista previa
    \item Persistencia del diseño en formato JSON
\end{itemize}

\textbf{Prioridad:} Crítica | \textbf{Story Points:} 21 | \textbf{Sprint:} Sprint 4

\vspace{0.5cm}

\textbf{HU-008: Integración de Monaco Editor}

\begin{itemize}
    \item \textbf{Como} desarrollador avanzado
    \item \textbf{Quiero} editar código manualmente con resaltado de sintaxis y autocompletado
    \item \textbf{Para} refinar el código generado por la IA
\end{itemize}

\textbf{Criterios de Aceptación:}
\begin{itemize}
    \item Monaco Editor integrado en la interfaz
    \item Soporte para JSON, JavaScript, TypeScript, SQL, HTML
    \item Autocompletado funcional
\end{itemize}

\textbf{Prioridad:} Alta | \textbf{Story Points:} 13 | \textbf{Sprint:} Sprint 4

\vspace{0.5cm}

\textbf{Épica 6: Sprint 5 - Renderizado y Bases de Datos}

\vspace{0.3cm}

\textbf{HU-009: Transformación JSON a Componentes Visuales}

\begin{itemize}
    \item \textbf{Como} sistema
    \item \textbf{Quiero} interpretar estructuras JSON y renderizar componentes visuales correspondientes
    \item \textbf{Para} mostrar la aplicación generada por la IA
\end{itemize}

\textbf{Criterios de Aceptación:}
\begin{itemize}
    \item Algoritmo de parsing de JSON a componentes React
    \item Mapeo de tipos de datos a controles UI (text $\rightarrow$ input, select $\rightarrow$ dropdown)
    \item Renderizado dinámico sin recarga de página
    \item Manejo de errores en JSON malformado
    \item Pruebas con 10+ estructuras de aplicación diferentes
\end{itemize}

\textbf{Prioridad:} Crítica | \textbf{Story Points:} 13 | \textbf{Sprint:} Sprint 5

\vspace{0.5cm}

\textbf{HU-010: Conexión Multi-Motor de Base de Datos}

\begin{itemize}
    \item \textbf{Como} desarrollador
    \item \textbf{Quiero} conectar la plataforma a MySQL y SQL Server
    \item \textbf{Para} gestionar datos de aplicaciones en diferentes espacios
\end{itemize}

\textbf{Criterios de Aceptación:}
\begin{itemize}
    \item Servicio de conexión a MySQL implementado
    \item Servicio de conexión a SQL Server implementado
    \item Pool de conexiones configurado para optimizar rendimiento
    \item Endpoint /api/database/connect con validación de credenciales
    \item Manejo de errores de conexión y timeout
\end{itemize}

\textbf{Prioridad:} Alta | \textbf{Story Points:} 8 | \textbf{Sprint:} Sprint 5

\vspace{0.5cm}

\textbf{Épica 7: Sprint 6 - Gestión de Datos Avanzada}

\vspace{0.3cm}

\textbf{HU-011: Administrador de Base de Datos Asistido por IA}

\begin{itemize}
    \item \textbf{Como} desarrollador
    \item \textbf{Quiero} realizar query SQL mediante lenguaje natural
    \item \textbf{Para} optimizar el tiempo de análisis de datos
\end{itemize}

\textbf{Criterios de Aceptación:}
\begin{itemize}
    \item Endpoint /api/database/query-ai que traduce lenguaje natural a SQL
\end{itemize}

\textbf{Prioridad:} Media | \textbf{Story Points:} 13 | \textbf{Sprint:} Sprint 6

\vspace{0.5cm}

\textbf{Épica 8: Sprint 7 - Asistente de Chat y Sesiones}

\vspace{0.3cm}

\textbf{HU-012: Chat de Asistencia con IA}

\begin{itemize}
    \item \textbf{Como} usuario
    \item \textbf{Quiero} interactuar con un asistente de IA mediante chat
    \item \textbf{Para} recibir ayuda contextual durante el desarrollo
\end{itemize}

\textbf{Criterios de Aceptación:}
\begin{itemize}
    \item Interfaz de chat integrada en la plataforma
    \item Conexión con AWS Bedrock para respuestas inteligentes
    \item Contexto de conversación mantenido
    \item Sugerencias y mejores prácticas
\end{itemize}

\textbf{Prioridad:} Media | \textbf{Story Points:} 13 | \textbf{Sprint:} Sprint 7

\vspace{0.5cm}

\textbf{HU-013: Guardado y Recuperación de Sesiones}

\begin{itemize}
    \item \textbf{Como} usuario
    \item \textbf{Quiero} guardar mi progreso y recuperarlo en sesiones futuras
    \item \textbf{Para} no perder mi trabajo al cerrar la plataforma
\end{itemize}

\textbf{Criterios de Aceptación:}
\begin{itemize}
    \item Endpoint /api/sessions/save para persistir estado
    \item Endpoint /api/sessions/load para recuperar sesión
    \item Interfaz para listar sesiones guardadas
\end{itemize}

\textbf{Prioridad:} Alta | \textbf{Story Points:} 8 | \textbf{Sprint:} Sprint 7

\vspace{0.5cm}

\textbf{Épica 9: Sprint 8 - Gestión de Componentes}

\vspace{0.3cm}

\textbf{HU-014: Gestión de componentes de Usuario}

\begin{itemize}
    \item \textbf{Como} usuario
    \item \textbf{Quiero} ver un listado de todos mis componentes creados
    \item \textbf{Para} organizarlos y acceder rápidamente a ellos
\end{itemize}

\textbf{Criterios de Aceptación:}
\begin{itemize}
    \item Endpoint /api/apps/list con paginación
    \item Interfaz de tarjetas con descripción de componentes
    \item Acciones: editar, duplicar, eliminar
    \item Confirmación antes de eliminar
\end{itemize}

\textbf{Prioridad:} Media | \textbf{Story Points:} 5 | \textbf{Sprint:} Sprint 8

\vspace{0.5cm}

\textbf{Épica 10: Sprint 9 - Personalización}

\vspace{0.3cm}

\textbf{HU-015: Sistema de Temas Personalizable}

\begin{itemize}
    \item \textbf{Como} usuario
    \item \textbf{Quiero} personalizar la apariencia del editor de código
    \item \textbf{Para} trabajar con un tema visual que me resulte cómodo
\end{itemize}

\textbf{Criterios de Aceptación:}
\begin{itemize}
    \item Selector de temas en configuración de usuario
    \item Mínimo 20 temas predefinidos (Monokai, Dracula, GitHub, etc.)
    \item Persistencia de preferencia de tema
    \item Aplicación inmediata sin recarga
    \item Vista previa de temas antes de aplicar
\end{itemize}

\textbf{Prioridad:} Baja | \textbf{Story Points:} 5 | \textbf{Sprint:} Sprint 9

\vspace{0.5cm}

\textbf{Épica 11: Sprint 10 - Despliegue y Validación Final}

\vspace{0.3cm}

\textbf{HU-016: Despliegue en Producción}

\begin{itemize}
    \item \textbf{Como} Product Owner
    \item \textbf{Quiero} desplegar la plataforma en un entorno de producción
    \item \textbf{Para} que el equipo de Proyectos pueda comenzar a utilizarla
\end{itemize}

\textbf{Criterios de Aceptación:}
\begin{itemize}
    \item Pipeline CI/CD desplegando automáticamente a producción
    \item CodePipeline con 6 etapas configuradas (Source, Build, Deploy, Approval, CreateAMI, UpdateASG)
    \item CodeBuild projects operativos (Frontend, Backend, Deploy, AMI, ASG)
    \item ECR creados y funcionales
    \item Auto Scaling Group con Target Groups
    \item S3 para artefactos
    \item Monitoreo y logs configurados (CloudWatch)
    \item Plan de rollback de versionado
\end{itemize}

\textbf{Prioridad:} Crítica | \textbf{Story Points:} 13 | \textbf{Sprint:} Sprint 10

\vspace{0.5cm}

\textbf{HU-017: Pruebas de Integración Final}

\begin{itemize}
    \item \textbf{Como} Product Owner
    \item \textbf{Quiero} ejecutar pruebas de integración completas del sistema
    \item \textbf{Para} validar que todos los componentes funcionan correctamente en conjunto
\end{itemize}

\textbf{Criterios de Aceptación:}
\begin{itemize}
    \item Suite de pruebas de integración ejecutándose exitosamente
    \item Pruebas end-to-end de flujos críticos (generación, edición, guardado)
    \item Validación de integración con servicios AWS (Bedrock, S3, Cognito)
    \item Pruebas de carga y rendimiento
    \item Documentación de casos de prueba y resultados
    \item Cobertura de pruebas >80\%
\end{itemize}

\textbf{Prioridad:} Crítica | \textbf{Story Points:} 8 | \textbf{Sprint:} Sprint 10

\vspace{0.5cm}

\textbf{Épica 12: Sprint 11 - Buffer y Cierre}

\vspace{0.3cm}

\textbf{HU-018: Resolver Deuda Técnica y Preparar Entrega Final}

\begin{itemize}
    \item \textbf{Como} equipo de desarrollo
    \item \textbf{Quiero} resolver la deuda técnica acumulada y preparar la documentación final
    \item \textbf{Para} entregar un producto de calidad con documentación completa
\end{itemize}

\textbf{Criterios de Aceptación:}
\begin{itemize}
    \item Refactorización de código con deuda técnica identificada
    \item Optimización de rendimiento en áreas críticas
    \item Documentación técnica completa (README, guías de instalación, API docs)
    \item Documentación de usuario final
    \item Video demo de funcionalidades principales
    \item Preparación de presentación final
    \item Entrega de código fuente y artefactos
\end{itemize}

\textbf{Prioridad:} Alta | \textbf{Story Points:} 8 | \textbf{Sprint:} Sprint 11

\vspace{0.5cm}

\textbf{Resumen del Product Backlog:}

El Product Backlog completo consta de:
\begin{itemize}
    \item \textbf{Total de Épicas:} 12 épicas principales
    \item \textbf{Total de Historias de Usuario:} 18 historias de usuario
    \item \textbf{Total de Story Points:} 159 story points
    \item \textbf{Duración Total:} 6 meses (11 sprints de 2 semanas + 1 sprint de 5 días)
    \item \textbf{Velocidad Promedio Estimada:} 14.5 story points por sprint
\end{itemize}

La distribución de story points por sprint se muestra en la Tabla \ref{tab:story_points_sprint}:

\begin{table}[H]
\centering
\caption{Distribución de Story Points por Sprint}
\label{tab:story_points_sprint}
\begin{tabular}{|l|c|l|}
\hline
\textbf{Sprint} & \textbf{Story Points} & \textbf{Historias de Usuario} \\
\hline
Sprint 0 & 13 & HU-001, HU-002 \\
\hline
Sprint 1 & 8 & HU-003 \\
\hline
Sprint 2 & 26 & HU-004, HU-005 \\
\hline
Sprint 3 & 13 & HU-006 \\
\hline
Sprint 4 & 34 & HU-007, HU-008 \\
\hline
Sprint 5 & 21 & HU-009, HU-010 \\
\hline
Sprint 6 & 13 & HU-011 \\
\hline
Sprint 7 & 21 & HU-012, HU-013 \\
\hline
Sprint 8 & 5 & HU-014 \\
\hline
Sprint 9 & 5 & HU-015 \\
\hline
Sprint 10 & 21 & HU-016, HU-017 \\
\hline
Sprint 11 & 8 & HU-018 \\
\hline
\textbf{Total} & \textbf{159} & \textbf{18 HU} \\
\hline
\end{tabular}
\end{table}


\subsubsection{Priorización de tareas en Jira}

La gestión y priorización del Product Backlog se realizó utilizando Jira, la plataforma de gestión ágil de Atlassian. Jira permite visualizar, organizar y priorizar las historias de usuario de manera eficiente, facilitando la planificación de Sprints y el seguimiento del progreso del proyecto.

En Jira, el proyecto se estructuró de la siguiente manera:
\begin{itemize}
    \item \textbf{Épicas:} Cada sprint se representó como una épica en Jira (IR-3 a IR-14), agrupando las historias de usuario correspondientes
    \item \textbf{Historias de Usuario:} Cada HU se creó como una historia vinculada a su épica padre (IR-15 a IR-32)
    \item \textbf{Estados:} Las historias transicionaron por los estados: Tareas por hacer $\rightarrow$ En curso $\rightarrow$ Finalizada
    \item \textbf{Campos Personalizados:} Se configuraron campos para Story Points, Sprint, fechas de inicio y vencimiento
\end{itemize}

La Figura \ref{fig:jira_priorizacion} muestra el tablero de Jira con las épicas e historias de usuario organizadas cronológicamente. Las historias críticas relacionadas con la arquitectura base (Sprint 0) y la integración de AWS Bedrock (Sprint 2) fueron priorizadas en los primeros Sprints, mientras que las funcionalidades de personalización y optimización se programaron para Sprints posteriores.

\textbf{Nota:} El tablero completo de Jira puede consultarse en: \url{[ENLACE INTERNO CENSURADO]}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{imagenes/4.1.2Priorización de tareas en Jira.png}
    \caption{Priorización de tareas en Jira para el proyecto Irakani Builder}
    \label{fig:jira_priorizacion}
\end{figure}

La priorización se basó en los siguientes criterios:

\begin{itemize}
    \item \textbf{Valor de Negocio:} Impacto directo en la reducción de costos operativos y mejora de la productividad del equipo de Proyectos.
    \item \textbf{Dependencias Técnicas:} Funcionalidades que son prerequisitos para otras historias de usuario (ej. autenticación antes de gestión de sesiones).
    \item \textbf{Riesgo Técnico:} Historias con mayor incertidumbre o complejidad se priorizaron temprano para mitigar riesgos.
    \item \textbf{Esfuerzo Estimado:} Medido en Story Points utilizando la secuencia de Fibonacci (1, 2, 3, 5, 8, 13, 21).
\end{itemize}

El Product Owner (Luis Flores) fue responsable de mantener y ajustar continuamente estas prioridades en función de la retroalimentación del equipo y los cambios en las necesidades del negocio, siguiendo los principios de Scrum de inspección y adaptación.


\subsection{Diseño de la Arquitectura y Flujo de Datos}

\subsubsection{Arquitectura de Microservicios y Comunicación}

La arquitectura de Irakani Builder se diseñó siguiendo el patrón de microservicios, donde cada componente del sistema opera como un servicio independiente y autónomo. Esta decisión arquitectónica responde directamente a la necesidad de evitar la deuda técnica que caracterizaba a la plataforma anterior (app.irakani.com) y garantizar la escalabilidad, mantenibilidad y resiliencia del sistema.

La Figura \ref{fig:arquitectura_microservicios} ilustra la arquitectura completa del sistema, mostrando la interacción entre los diferentes componentes y servicios.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{imagenes/arquitectura.png}
    \caption{Arquitectura de microservicios de Irakani Builder}
    \label{fig:arquitectura_microservicios}
\end{figure}

\textbf{Componentes Principales de la Arquitectura:}

\begin{enumerate}
    \item \textbf{Capa de Presentación - Frontend (React 18):}
    \begin{itemize}
        \item Interfaz de usuario construida con React 18 y TypeScript
        \item Componentes reutilizables para el editor visual
        \item Integración de Monaco Editor para edición de código
        \item Sistema de temas personalizable
        \item Comunicación con el backend mediante APIs RESTful
    \end{itemize}
    
    \item \textbf{Capa de Aplicación - Backend (Node.js):}
    \begin{itemize}
        \item Servidor Node.js con arquitectura basada en Express.js
        \item Gestión de autenticación y autorización mediante JWT
        \item Orquestación de llamadas a microservicios especializados
        \item Manejo de sesiones de usuario
        \item Validación de datos y lógica de negocio
    \end{itemize}
    
    \item \textbf{Microservicios Especializados:}
    \begin{itemize}
        \item \textbf{Auth Service (AWS Cognito):} Gestión de autenticación y autorización de usuarios, generación y validación de tokens JWT
        \item \textbf{AI Service (AWS Bedrock):} Servicio de generación de código asistida por IA, procesamiento de prompts y generación de estructuras JSON
        \item \textbf{Database Service:} Gestión de conexiones a múltiples motores de bases de datos (MySQL, SQL Server), ejecución de queries y optimización de consultas
    \end{itemize}
    
    \item \textbf{Capa de Datos:}
    \begin{itemize}
        \item \textbf{S3 (Amazon S3):} Almacenamiento de artefactos, archivos estáticos y backups
        \item \textbf{Irakani Database:} Base de datos principal para almacenar metadatos de aplicaciones, sesiones de usuario y configuraciones
    \end{itemize}
    
    \item \textbf{Capa de Caché (Valkey):}
    \begin{itemize}
        \item Sistema de caché distribuido para mejorar el rendimiento
        \item Almacenamiento temporal de respuestas de IA frecuentes
        \item Gestión de sesiones activas
        \item Reducción de latencia en operaciones repetitivas
    \end{itemize}
\end{enumerate}

\textbf{Ventajas de esta Arquitectura:}

\begin{itemize}
    \item \textbf{Escalabilidad Independiente:} Cada microservicio puede escalarse de forma independiente según la demanda
    \item \textbf{Tolerancia a Fallos:} Un fallo en un servicio no compromete la operación de todo el sistema
    \item \textbf{Flexibilidad Tecnológica:} Cada servicio puede utilizar el stack tecnológico más adecuado para su función
    \item \textbf{Facilidad de Mantenimiento:} Los servicios pueden actualizarse y desplegarse de forma independiente
    \item \textbf{Desarrollo Paralelo:} Diferentes equipos pueden trabajar en servicios distintos simultáneamente
\end{itemize}


\subsubsection{Estrategia de Integración de Datos (API Wrapper)}

El sistema Irakani Builder implementa una arquitectura de Backend for Frontend (BFF) que actúa como capa de abstracción entre el frontend React y los servicios externos de AWS. Esta estrategia permite centralizar la lógica de integración, gestionar la autenticación, y optimizar las peticiones hacia los servicios de almacenamiento y procesamiento.

\textbf{A) Arquitectura de Integración:}

El sistema se conecta directamente a una API de Irakani legado, además implementa su propio backend (Node.js/Express) que orquesta las operaciones con servicios de AWS:

\begin{enumerate}
    \item Frontend (React + TypeScript) $\rightarrow$ Backend BFF (Node.js/Express) $\rightarrow$ Servicios AWS (S3, DynamoDB, Bedrock, Step Functions)
    \item Servicios de Integración Implementados:
    \begin{itemize}
        \item \texttt{irakaniApi.ts}: Cliente para operaciones de almacenamiento en la base de datos del espacio
        \item \texttt{databaseService.ts}: Cliente para gestión de conexiones a bases de datos (MySQL, SQL Server)
        \item \texttt{authService.ts}: Gestión de autenticación con AWS Cognito
        \item \texttt{bedrockChatService.ts}: Integración con modelos de IA de AWS Bedrock
    \end{itemize}
\end{enumerate}

\textbf{B) Endpoints del Backend BFF y sus Interfaces JSON:}

\textbf{1. OPERACIONES DE ALMACENAMIENTO (S3):}

\textbf{Endpoint:} \texttt{POST /api/s3/upload}

\textbf{Propósito:} Guardar estado de aplicaciones generadas con versionamiento

\textbf{Request Body:}
\begin{lstlisting}[caption={Request Body para guardar en S3}]
{
  "bucket": "string",           // Nombre del bucket S3
  "key": "string",              // Ruta del archivo
  "data": "object",             // Datos JSON de la aplicacion
  "userId": "string",           // ID del usuario
  "appName": "string"           // Nombre de la aplicacion
}
\end{lstlisting}

\textbf{Response:}
\begin{lstlisting}[caption={Response de S3 Upload}]
{
  "success": true,
  "versionId": "string",        // ID de version de S3
  "appId": "string",            // ID unico de la aplicacion
  "message": "string"
}
\end{lstlisting}

\textbf{Endpoint:} \texttt{POST /api/s3/download}

\textbf{Propósito:} Recuperar estado de aplicaciones desde S3

\textbf{Request Body:}
\begin{lstlisting}[caption={Request Body para S3 Download}]
{
  "bucket": "string",
  "key": "string"
}
\end{lstlisting}

\textbf{Response:} JSON con el contenido del archivo almacenado


\textbf{2. OPERACIONES DE REGISTRO DE APLICACIONES (DynamoDB):}

\textbf{Endpoint:} \texttt{GET /api/user/:userId/apps}

\textbf{Propósito:} Listar todas las aplicaciones de un usuario

\textbf{Response:}
\begin{lstlisting}[caption={Response de listado de aplicaciones}]
{
  "apps": [
    {
      "appId": "string",
      "appName": "string",
      "s3Key": "string",
      "s3Bucket": "string",
      "versionId": "string",
      "createdAt": "ISO8601",
      "updatedAt": "ISO8601"
    }
  ]
}
\end{lstlisting}

\textbf{Endpoint:} \texttt{DELETE /api/user/:userId/apps/:appId}

\textbf{Propósito:} Eliminar registro de aplicación

\textbf{Response:}
\begin{lstlisting}[caption={Response de eliminacion}]
{
  "success": true,
  "message": "string"
}
\end{lstlisting}

\textbf{3. OPERACIONES DE INTELIGENCIA ARTIFICIAL (AWS Bedrock):}

\textbf{Endpoint:} \texttt{POST /api/chat/bedrock}

\textbf{Propósito:} Chat con IA para asistencia en desarrollo

\textbf{Request Body:}
\begin{lstlisting}[caption={Request Body para chat con Bedrock}]
{
  "messages": [
    {
      "role": "user o assistant",
      "content": [{ "text": "string" }]
    }
  ],
  "systemPrompt": "string"      // Opcional
}
\end{lstlisting}

\textbf{Response:}
\begin{lstlisting}[caption={Response del chat}]
{
  "message": "string"            // Respuesta del modelo
}
\end{lstlisting}

\textbf{Endpoint:} \texttt{POST /api/chat/bedrock/stream}

\textbf{Propósito:} Chat con streaming para respuestas en tiempo real

\textbf{Request Body:} Igual que \texttt{/api/chat/bedrock}

\textbf{Response:} Server-Sent Events (SSE) con chunks de texto


\textbf{4. OPERACIONES DE GENERACIÓN (Step Functions):}

\textbf{Endpoint:} \texttt{POST /api/analyze}

\textbf{Propósito:} Analizar requerimientos para generación de aplicaciones

\textbf{Endpoint:} \texttt{POST /api/generate}

\textbf{Propósito:} Generar código de aplicación

\textbf{Endpoint:} \texttt{POST /api/stepfunctions/status}

\textbf{Propósito:} Consultar estado de ejecución de Step Functions

\textbf{Request Body:}
\begin{lstlisting}[caption={Request Body para consultar estado}]
{
  "executionArn": "string"
}
\end{lstlisting}

\textbf{Response:} Estado de la ejecución (RUNNING, SUCCEEDED, FAILED, etc.)

\textbf{5. OPERACIONES DE BASE DE DATOS:}

\textbf{Endpoint:} \texttt{POST /api/database/connect}

\textbf{Propósito:} Establecer conexión a base de datos externa

\textbf{Request Body:}
\begin{lstlisting}[caption={Request Body para conexion a BD}]
{
  "dbType": "mysql o sqlserver o cloudflare",
  "config": {
    "host": "string",           // Para MySQL
    "server": "string",         // Para SQL Server
    "user": "string",
    "password": "string",
    "database": "string",
    "port": "number",           // Opcional
    "encrypt": "boolean",       // SQL Server
    "trustServerCertificate": "boolean",
    "ssl": "boolean"            // MySQL
  }
}
\end{lstlisting}

\textbf{Response:}
\begin{lstlisting}[caption={Response de conexion a BD}]
{
  "connectionId": "string",     // ID unico de conexion
  "token": "string",            // Token de autenticacion
  "status": "connected",
  "dbType": "string",
  "databaseName": "string"
}
\end{lstlisting}

\textbf{Endpoint:} \texttt{POST /api/database/query}

\textbf{Propósito:} Ejecutar consultas SQL

\textbf{Headers:}
\begin{lstlisting}[caption={Headers requeridos}]
Authorization: Bearer {token}
X-Connection-Id: {connectionId}
\end{lstlisting}

\textbf{Request Body:}
\begin{lstlisting}[caption={Request Body para ejecutar query}]
{
  "query": "string",
  "params": ["any"]             // Parametros preparados
}
\end{lstlisting}

\textbf{Response:}
\begin{lstlisting}[caption={Response de query SQL}]
{
  "rows": ["object"],           // Resultados de la consulta
  "fields": ["object"],         // Metadatos de columnas
  "rowCount": "number"
}
\end{lstlisting}


\textbf{Endpoint:} \texttt{GET /api/database/tables}

\textbf{Propósito:} Obtener lista de tablas de la base de datos

\textbf{Headers:} Authorization, X-Connection-Id, X-User-Id

\textbf{Response:}
\begin{lstlisting}[caption={Response de listado de tablas}]
{
  "tables": [
    {
      "name": "string",
      "schema": "string",       // Opcional
      "type": "TABLE o VIEW"
    }
  ]
}
\end{lstlisting}

\textbf{Endpoint:} \texttt{GET /api/database/tables/:tableName/structure}

\textbf{Prop\'osito:} Obtener estructura de una tabla

\textbf{Response:}
\begin{lstlisting}[caption={Response de estructura de tabla}]
{
  "columns": [
    {
      "name": "string",
      "type": "string",
      "nullable": "boolean",
      "key": "PRI o UNI o vacio",
      "default": "any",
      "extra": "string"
    }
  ]
}
\end{lstlisting}

\textbf{Endpoint:} \texttt{POST /api/database/disconnect}

\textbf{Propósito:} Cerrar conexión a base de datos

\textbf{Headers:} Authorization, X-Connection-Id

\textbf{6. OPERACIONES DE GENERACIÓN DE ICONOS:}

\textbf{Endpoint:} \texttt{POST /api/generate-icon}

\textbf{Propósito:} Generar iconos usando IA (Titan Image Generator)

\textbf{Request Body:}
\begin{lstlisting}[caption={Request Body para generar icono}]
{
  "prompt": "string",           // Descripcion del icono
  "bucket": "string",           // Opcional
  "userId": "string"
}
\end{lstlisting}

\textbf{Response:}
\begin{lstlisting}[caption={Response de generacion de icono}]
{
  "imageUrl": "string",         // URL local del icono
  "s3Key": "string",
  "s3Bucket": "string",
  "originalPrompt": "string",
  "translatedPrompt": "string", // Traduccion al ingles
  "customColor": "string",      // Color hex
  "tokenUsage": {
    "haiku": {
      "inputTokens": "number",
      "outputTokens": "number",
      "model": "string"
    },
    "titan": {
      "imagesGenerated": "number",
      "model": "string"
    }
  }
}
\end{lstlisting}

\textbf{Endpoint:} \texttt{GET /api/imagen/:imagenKey}

\textbf{Propósito:} Servir imágenes almacenadas en S3

\textbf{Response:} Imagen binaria (image/png o image/jpeg)


\textbf{C) Gestión de Sesiones y Autenticación:}

\textbf{1. Autenticación con AWS Cognito:}
\begin{itemize}
    \item El \texttt{authService.ts} gestiona el flujo de autenticación
    \item Las credenciales se almacenan en Valkey para persistencia
    \item Cada petición al backend incluye headers de identificación:
    \begin{itemize}
        \item \texttt{X-User-Id}: Username de Cognito
        \item \texttt{X-Context}: Contexto de la operación
        \item \texttt{X-Schema}: Esquema de datos utilizado
    \end{itemize}
\end{itemize}

\textbf{2. Tokens de Conexión a Base de Datos:}
\begin{itemize}
    \item Cada conexión genera un token único
    \item Los tokens se validan en cada petición
    \item Las conexiones se almacenan en Valkey por usuario
\end{itemize}

\textbf{D) Patrón de Wrapper Implementado:}

El servicio \texttt{irakaniApi.ts} implementa un patrón de wrapper que:

\begin{enumerate}
    \item Centraliza la configuración de endpoints (\texttt{apiConfig.ts})
    \item Abstrae la complejidad de las peticiones HTTP
    \item Maneja errores de forma consistente
    \item Proporciona una interfaz TypeScript tipada
    \item Permite mock de servicios para desarrollo (\texttt{mockServices.ts})
\end{enumerate}

\textbf{Ejemplo de implementación del wrapper:}

\begin{lstlisting}[caption={Implementacion del wrapper en TypeScript}]
// src/services/irakaniApi.ts
export const irakaniApi = {
  async saveToS3(data: any): Promise<any> {
    const backendUrl = `${apiConfig.baseUrl}${apiConfig.endpoints.s3Upload}`;
    const response = await fetch(backendUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        bucket: apiConfig.bucket,
        key: data.fileName || 'improved/app-state.json',
        data: data.jsonData || data,
        userId: data.userId,
        appName: data.appName
      })
    });
    
    if (!response.ok) {
      throw new Error(`Error ${response.status}: ${await response.text()}`);
    }
    
    return await response.json();
  }
}
\end{lstlisting}

\textbf{E) Trazabilidad y Monitoreo:}

El backend implementa trazabilidad completa de operaciones:

\begin{enumerate}
    \item Logging de tokens consumidos por modelo de IA
    \item Cálculo de costos por operación
    \item Registro en DynamoDB (tabla UsageLogService) de:
    \begin{itemize}
        \item Tokens de entrada/salida
        \item Modelo utilizado
        \item Usuario y contexto
        \item Timestamp de operación
        \item Costo estimado
    \end{itemize}
\end{enumerate}

Esta arquitectura permite una integración escalable, mantenible y observable con los servicios de AWS, sin depender de una API REST legado de Irakani.


\subsubsection{Diseño de Gestión de Sesiones y Caché (Valkey)}

Valkey es un almacén de datos en memoria de código abierto, compatible con Redis, que proporciona almacenamiento de estructuras de datos de alta velocidad. En Irakani Builder, Valkey se utiliza como capa de caché distribuida y sistema de gestión de sesiones, reemplazando el uso tradicional de localStorage del navegador con una solución centralizada y escalable.

\textbf{A) Justificación del Uso de Valkey:}

\begin{enumerate}
    \item \textbf{Rendimiento y Baja Latencia:}
    \begin{itemize}
        \item Almacenamiento en memoria RAM: Valkey opera completamente en memoria, proporcionando tiempos de respuesta en microsegundos (sub-milisegundo) para operaciones de lectura/escritura
        \item Operaciones atómicas: Las operaciones SET/GET son atómicas, garantizando consistencia sin necesidad de bloqueos complejos
        \item Throughput elevado: Capaz de manejar cientos de miles de operaciones por segundo, ideal para aplicaciones con múltiples usuarios concurrentes
    \end{itemize}
    
    \item \textbf{Persistencia de Sesiones Multi-Dispositivo:}
    \begin{itemize}
        \item A diferencia de localStorage (limitado al navegador local), Valkey permite que un usuario acceda a su sesión desde cualquier dispositivo
        \item Las sesiones persisten incluso si el usuario cierra el navegador o cambia de máquina
        \item Soporte para múltiples sesiones simultáneas por usuario (desarrollo paralelo de diferentes aplicaciones)
    \end{itemize}
    
    \item \textbf{Escalabilidad Horizontal:}
    \begin{itemize}
        \item Valkey Cluster (implementado en AWS ElastiCache) permite distribución automática de datos entre múltiples nodos
        \item Capacidad de escalar agregando más nodos sin tiempo de inactividad
        \item Replicación automática para alta disponibilidad
    \end{itemize}
    
    \item \textbf{Gestión Centralizada de Estado:}
    \begin{itemize}
        \item Todos los estados temporales del editor (tema, conexiones DB, tokens, configuraciones) se centralizan en un único sistema
        \item Facilita la sincronización entre diferentes componentes de la aplicación
        \item Simplifica el debugging y monitoreo de sesiones activas
    \end{itemize}
    
    \item \textbf{Expiración Automática (TTL):}
    \begin{itemize}
        \item Soporte nativo para Time-To-Live (TTL) en claves
        \item Limpieza automática de datos obsoletos sin intervención manual
        \item Gestión eficiente de memoria al eliminar sesiones inactivas
    \end{itemize}
    
    \item \textbf{Fallback a localStorage:}
    \begin{itemize}
        \item La implementación incluye un mecanismo de fallback automático a localStorage si Valkey no está disponible
        \item Garantiza que la aplicación siga funcionando incluso con problemas de conectividad
    \end{itemize}
\end{enumerate}

\textbf{B) Arquitectura de Integración con Valkey:}

La integración se implementa en tres capas:

\begin{enumerate}
    \item \textbf{Capa de Infraestructura (AWS ElastiCache):}
    \begin{itemize}
        \item Cluster: \texttt{[REDACTED]}
        \item Puerto: [REDACTED] (protocolo Redis)
        \item Modo: Cluster con replicación automática
        \item Región: [REGIÓN_AWS_CENSURADA]
    \end{itemize}
    
    \item \textbf{Capa de Backend (Node.js):}
    \begin{itemize}
        \item Cliente: redis (npm package compatible con Valkey)
        \item Rutas: \texttt{/api/valkey/*} (\texttt{backend/routes/valkey.js})
        \item Gestión de conexión con retry automático
        \item Middleware de verificación de disponibilidad
    \end{itemize}
    
    \item \textbf{Capa de Frontend (TypeScript):}
    \begin{itemize}
        \item \texttt{valkeyService.ts}: Cliente base para operaciones CRUD
        \item \texttt{userValkeyService.ts}: Servicio con contexto de usuario y sesiones
        \item Fallback automático a localStorage
    \end{itemize}
\end{enumerate}


\textbf{C) Estructura de Datos en Caché (Key-Value Pairs):}

El sistema implementa una jerarquía de claves estructurada para organizar los datos por usuario y sesión:

\begin{enumerate}
    \item \textbf{Claves Globales (sin usuario):}
    \begin{itemize}
        \item Patrón: \texttt{global:\{key\}}
        \item Uso: Configuraciones compartidas o datos temporales sin autenticación
        \item Ejemplo: \texttt{global:app-config}
    \end{itemize}
    
    \item \textbf{Claves de Usuario (sin sesión específica):}
    \begin{itemize}
        \item Patrón: \texttt{user:\{userId\}:\{key\}}
        \item Uso: Datos persistentes del usuario que no dependen de una sesión
        \item Ejemplos:
        \begin{itemize}
            \item \texttt{user:johndoe:sessions:list} $\rightarrow$ ["session\_1234", "session\_5678"]
            \item \texttt{user:johndoe:sessions:active} $\rightarrow$ "session\_1234"
            \item \texttt{user:johndoe:cognito-session} $\rightarrow$ \{"username":"johndoe",...\}
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Claves de Sesión de Usuario (contexto completo):}
    \begin{itemize}
        \item Patrón: \texttt{user:\{userId\}:session:\{sessionId\}:\{key\}}
        \item Uso: Datos específicos de una sesión de trabajo (aplicación en desarrollo)
        \item Ejemplos:
        \begin{itemize}
            \item \texttt{user:johndoe:session:session\_1234:editor-theme} $\rightarrow$ "vs-dark"
            \item \texttt{user:johndoe:session:session\_1234:irakani-selected-space} $\rightarrow$ "12345"
            \item \texttt{user:johndoe:session:session\_1234:db\_connection\_ids} $\rightarrow$ ["conn\_001"]
            \item \texttt{user:johndoe:session:session\_1234:github\_token} $\rightarrow$ "ghp\_..."
        \end{itemize}
    \end{itemize}
\end{enumerate}

\textbf{D) Tipos de Datos Almacenados:}

\begin{enumerate}
    \item \textbf{Sesiones de Autenticación:}
    \begin{itemize}
        \item Clave: \texttt{cognito-session}
        \item TTL: Sin expiración (se elimina en logout)
    \end{itemize}
    
    \item \textbf{Configuraciones del Editor:}
    \begin{itemize}
        \item Clave: \texttt{editor-theme}
        \item Valores: ``vs-dark'' $|$ ``vs-light'' $|$ ``hc-black'' $|$ ``monokai'' $|$ ... (20+ temas)
        \item TTL: Sin expiración
    \end{itemize}
    
    \item \textbf{Conexiones a Bases de Datos:}
    \begin{itemize}
        \item Clave: \texttt{db\_connection\_\{connectionId\}}
        \item TTL: 24 horas (renovable con actividad)
    \end{itemize}
    
    \item \textbf{Tokens de Integración:}
    \begin{itemize}
        \item Claves: \texttt{github\_token}, \texttt{irakani-app-token}
        \item Valores: Strings de tokens JWT o API keys
        \item TTL: Según política de cada servicio
    \end{itemize}
    
    \item \textbf{Estado de Aplicación en Desarrollo:}
    \begin{itemize}
        \item Clave: \texttt{irakani-app-storage}
        \item Estructura: JSON completo del estado de la aplicación (puede ser varios MB)
        \item TTL: 7 días de inactividad
    \end{itemize}
    
    \item \textbf{Contexto de Espacio Irakani:}
    \begin{itemize}
        \item Clave: \texttt{irakani-selected-space}
        \item Valor: ID del espacio seleccionado
        \item TTL: Sin expiración
    \end{itemize}
    
    \item \textbf{Gestión de Sesiones:}
    \begin{itemize}
        \item Clave: \texttt{sessions:list} $\rightarrow$ ["sessionId1", "sessionId2", ...]
        \item Clave: \texttt{sessions:active} $\rightarrow$ "sessionId" (sesión actualmente en uso)
    \end{itemize}
\end{enumerate}


\textbf{E) Operaciones Implementadas:}

\textbf{1. Operaciones Básicas (\texttt{valkeyService.ts}):}

\begin{itemize}
    \item \texttt{setItem(key, value, ttl?)}: Almacena un valor con TTL opcional
    \item \texttt{getItem(key)}: Recupera un valor por clave
    \item \texttt{removeItem(key)}: Elimina una clave
    \item \texttt{clear()}: Limpia todas las claves (FLUSHALL)
    \item \texttt{exists(key)}: Verifica si una clave existe
    \item \texttt{keys(pattern)}: Busca claves por patrón (ej: "user:johndoe:*")
    \item \texttt{deleteMultiple(keys)}: Elimina múltiples claves en una operación
\end{itemize}

\textbf{2. Operaciones de Usuario y Sesión (\texttt{userValkeyService.ts}):}

\begin{itemize}
    \item \texttt{setCurrentUser(userId)}: Establece el contexto de usuario actual
    \item \texttt{setCurrentSession(sessionId)}: Establece la sesión activa
    \item \texttt{getCurrentSession()}: Obtiene la sesión activa del usuario
    \item \texttt{createSession(sessionName?)}: Crea una nueva sesión de trabajo
    \item \texttt{listSessions()}: Lista todas las sesiones del usuario
    \item \texttt{deleteSession(sessionId)}: Elimina una sesión y todas sus claves asociadas
    \item \texttt{setItem/getItem/removeItem/exists}: Con contexto automático de usuario y sesión
\end{itemize}

\textbf{F) Endpoints del Backend para Valkey:}

\begin{lstlisting}[caption={Endpoints de Valkey}]
POST /api/valkey/set
Request: { "key": "string", "value": "string", "ttl": number }
Response: { "success": true }

POST /api/valkey/get
Request: { "key": "string" }
Response: { "value": "string o null" }

POST /api/valkey/del
Request: { "key": "string" }
Response: { "success": true }

POST /api/valkey/clear
Request: {}
Response: { "success": true }

POST /api/valkey/exists
Request: { "key": "string" }
Response: { "exists": boolean }
\end{lstlisting}

\textbf{G) Estrategia de Migración y Compatibilidad:}

\begin{enumerate}
    \item \textbf{Migración Automática de Datos:}
    \begin{itemize}
        \item Al crear la primera sesión, el sistema migra automáticamente datos existentes del formato antiguo (\texttt{user:\{userId\}:\{key\}}) al nuevo formato con sesión
        \item Claves migradas: \texttt{editor-theme}, \texttt{db\_connection\_ids}, \texttt{github\_token}, \texttt{irakani-selected-space}, \texttt{cognito-session}, etc.
    \end{itemize}
    
    \item \textbf{Fallback a localStorage:}
    \begin{itemize}
        \item Todas las operaciones incluyen try-catch con fallback a localStorage
        \item Garantiza funcionamiento offline o con problemas de red
        \item Transparente para el código cliente
    \end{itemize}
    
    \item \textbf{Gestión de Errores:}
    \begin{itemize}
        \item Retry automático con backoff exponencial (hasta 10 intentos)
        \item Timeout de 1 hora para reintentos totales
        \item Logging detallado de errores de conexión
    \end{itemize}
\end{enumerate}

\textbf{H) Beneficios de la Arquitectura Implementada:}

\begin{enumerate}
    \item \textbf{Aislamiento de Sesiones:} Cada sesión de trabajo es independiente, permitiendo desarrollo paralelo de múltiples aplicaciones
    \item \textbf{Persistencia Confiable:} Los datos sobreviven a reinicios del navegador y cambios de dispositivo
    \item \textbf{Rendimiento Optimizado:} Operaciones en memoria con latencia sub-milisegundo
    \item \textbf{Escalabilidad:} Arquitectura preparada para miles de usuarios concurrentes
    \item \textbf{Mantenibilidad:} Estructura de claves clara y jerárquica facilita debugging
    \item \textbf{Resiliencia:} Fallback automático garantiza disponibilidad continua
\end{enumerate}

Esta arquitectura de caché con Valkey es fundamental para proporcionar una experiencia de usuario fluida y profesional, eliminando las limitaciones de localStorage y preparando el sistema para escalar a nivel empresarial.


\subsubsection{Diseño de la Integración con IA (AWS Bedrock)}

Irakani Builder implementa una integración completa con AWS Bedrock para proporcionar capacidades de IA generativa en múltiples contextos. La arquitectura se basa en un sistema de comunicación bidireccional entre el frontend (React) y el backend (Node.js), que actúa como intermediario con los servicios de AWS.

\textbf{A) Arquitectura de la Integración:}

\textbf{1. Componentes Principales:}

\textbf{Frontend (bedrockChatService.ts):}
\begin{itemize}
    \item Servicio centralizado para todas las interacciones con IA
    \item Gestión de historial de conversaciones por aplicación
    \item Manejo de contextos dinámicos y especializados
    \item Soporte para streaming de respuestas en tiempo real
    \item Comandos especiales (/icon, /code, /ticket)
    \item Caché de prompts contextuales para optimización
\end{itemize}

\textbf{Backend (server.js):}
\begin{itemize}
    \item Cliente AWS Bedrock Runtime configurado con SDK v3
    \item Endpoints REST para chat estándar y streaming
    \item Registro de uso de tokens y costos por usuario
    \item Integración con DynamoDB para persistencia de métricas
    \item Soporte para múltiples modelos de IA
\end{itemize}

Ejemplo de Configuración del Cliente AWS Bedrock:

\begin{lstlisting}[caption={Configuración del cliente AWS Bedrock en backend}]
const { BedrockRuntimeClient, ConverseCommand, 
        ConverseStreamCommand } = require('@aws-sdk/client-bedrock-runtime');

// Configuracion con soporte para rol IAM o credenciales explicitas
const awsConfig = {
  region: process.env.AWS_REGION || '[REDACTED]'
};

if (process.env.AWS_ACCESS_KEY_ID && process.env.AWS_SECRET_ACCESS_KEY) {
  awsConfig.credentials = {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
    sessionToken: process.env.AWS_SESSION_TOKEN
  };
}

const bedrockClient = new BedrockRuntimeClient(awsConfig);

// Precios por modelo (por 1000 tokens) - [REDACTED]
const MODEL_PRICING = {
  'claude-sonnet-4': { input: [REDACTED], output: [REDACTED] },
  'claude-3-5-haiku': { input: [REDACTED], output: [REDACTED] },
  'titan-image-generator-v2': { perImage: [REDACTED] }
};

function calculateCost(model, inputTokens = 0, outputTokens = 0) {
  const pricing = MODEL_PRICING[model];
  if (!pricing) return 0;
  const inputCost = (inputTokens / 1000) * pricing.input;
  const outputCost = (outputTokens / 1000) * pricing.output;
  return inputCost + outputCost;
}
\end{lstlisting}

\textbf{2. Modelos de IA Utilizados:}

\textbf{Claude Sonnet 4 (anthropic.claude-sonnet-4-20250514-v1:0):}
\begin{itemize}
    \item Modelo principal para generación de código y asistencia
    \item Ventana de contexto: 200K tokens
    \item Costo: [PRECIO CENSURADO] por 1K tokens
    \item Uso: Chat contextual, generación de aplicaciones, modificación de JSON
\end{itemize}

\textbf{Claude 3.5 Haiku (anthropic.claude-3-5-haiku-20241022-v1:0):}
\begin{itemize}
    \item Modelo alternativo para tareas más simples
    \item Costo: [PRECIO CENSURADO] por 1K tokens
    \item Uso: Respuestas rápidas, análisis ligeros
\end{itemize}

\textbf{Titan Image Generator V2 (amazon.titan-image-generator-v2:0):}
\begin{itemize}
    \item Generación de iconos y recursos gráficos
    \item Costo: [PRECIO CENSURADO] por imagen
    \item Uso: Comando /icon para crear iconos de aplicaciones
\end{itemize}

\textbf{Llama 4 Maverick 17B (meta.llama4-maverick-17b-instruct-v1:0):}
\begin{itemize}
    \item Modelo experimental para casos específicos
    \item Costo: [PRECIO CENSURADO] por 1K tokens
\end{itemize}

\textbf{B) Flujos de Comunicación:}

\textbf{1. Flujo de Chat Estándar (Sin Streaming):}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    node distance=0.6cm,
    startstop/.style={rectangle, rounded corners, minimum width=3cm, minimum height=0.7cm, text centered, draw=black, fill=red!30, font=\footnotesize},
    process/.style={rectangle, minimum width=3.5cm, minimum height=0.7cm, text centered, draw=black, fill=blue!20, font=\footnotesize},
    myarrow/.style={thick, ->, >=stealth}
]

\node (start) [startstop] {Usuario};
\node (step1) [process, below=of start] {Frontend (ChatInterface)};
\node (step2) [process, below=of step1] {bedrockChatService.sendMessage()};
\node (step3) [process, below=of step2] {POST /api/chat/bedrock};
\node (step4) [process, below=of step3] {Backend: ConverseCommand};
\node (step5) [process, below=of step4] {AWS Bedrock (Claude Sonnet 4)};
\node (step6) [process, below=of step5] {Respuesta completa};
\node (step7) [process, below=of step6] {Extraccion de JSON};
\node (step8) [process, below=of step7] {Actualizacion del estado};
\node (step9) [process, below=of step8] {Registro de uso};
\node (stop) [startstop, below=of step9] {Respuesta al usuario};

\draw [myarrow] (start) -- (step1);
\draw [myarrow] (step1) -- (step2);
\draw [myarrow] (step2) -- (step3);
\draw [myarrow] (step3) -- (step4);
\draw [myarrow] (step4) -- (step5);
\draw [myarrow] (step5) -- (step6);
\draw [myarrow] (step6) -- (step7);
\draw [myarrow] (step7) -- (step8);
\draw [myarrow] (step8) -- (step9);
\draw [myarrow] (step9) -- (stop);

\end{tikzpicture}
\caption{Diagrama de flujo: Chat estándar con AWS Bedrock}
\label{fig:flujo_chat_estandar}
\end{figure}

\textbf{2. Flujo de Chat con Streaming:}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    node distance=0.6cm,
    startstop/.style={rectangle, rounded corners, minimum width=3cm, minimum height=0.7cm, text centered, draw=black, fill=red!30, font=\footnotesize},
    process/.style={rectangle, minimum width=3.5cm, minimum height=0.7cm, text centered, draw=black, fill=blue!20, font=\footnotesize},
    myarrow/.style={thick, ->, >=stealth}
]

\node (start) [startstop] {Usuario};
\node (step1) [process, below=of start] {Frontend (ChatInterface)};
\node (step2) [process, below=of step1] {sendMessageStream()};
\node (step3) [process, below=of step2] {POST /api/chat/bedrock/stream};
\node (step4) [process, below=of step3] {Backend: ConverseStreamCommand};
\node (step5) [process, below=of step4] {AWS Bedrock (Claude Sonnet 4)};
\node (step6) [process, below=of step5] {Stream de chunks};
\node (step7) [process, below=of step6] {Server-Sent Events (SSE)};
\node (step8) [process, below=of step7] {Frontend: onChunk() callback};
\node (step9) [process, below=of step8] {Renderizado progresivo en UI};
\node (step10) [process, below=of step9] {Extraccion de JSON};
\node (stop) [startstop, below=of step10] {Registro de uso};

\draw [myarrow] (start) -- (step1);
\draw [myarrow] (step1) -- (step2);
\draw [myarrow] (step2) -- (step3);
\draw [myarrow] (step3) -- (step4);
\draw [myarrow] (step4) -- (step5);
\draw [myarrow] (step5) -- (step6);
\draw [myarrow] (step6) -- (step7);
\draw [myarrow] (step7) -- (step8);
\draw [myarrow] (step8) -- (step9);
\draw [myarrow] (step9) -- (step10);
\draw [myarrow] (step10) -- (stop);

\end{tikzpicture}
\caption{Diagrama de flujo: Chat con streaming en tiempo real}
\label{fig:flujo_chat_streaming}
\end{figure}

\textbf{C) Sistema de Contextos Dinámicos:}

El servicio implementa un sistema sofisticado de contextos que permite a la IA entender y modificar partes específicas de la aplicación:

\textbf{1. Contextos Globales:}
\begin{itemize}
    \item 'aplicacion': Toda la estructura de la aplicación
    \item 'listas': Todas las listas de datos
    \item 'perfiles': Todos los perfiles de usuario
    \item 'entidades': Todas las entidades de datos
    \item 'workflows': Todos los flujos de trabajo
\end{itemize}

\textbf{2. Contextos Específicos:}
\begin{itemize}
    \item 'lista-\{id\}': Una lista específica
    \item 'lista-\{id\}-campos': Solo los campos de una lista
    \item 'perfil-\{id\}': Un perfil específico
    \item 'entidad-\{id\}': Una entidad específica
    \item 'workflows-\{id\}': Un workflow específico
    \item 'formulario-\{index\}': Un formulario específico
    \item 'elemento-\{formIndex\}-\{elementId\}': Un elemento específico
    \item 'formulario-\{index\}-crear-elementos': Agregar elementos a un formulario
\end{itemize}

\textbf{3. Gestión de Contextos:}
\begin{itemize}
    \item Caché de prompts por contexto para evitar regeneración
    \item Limpieza automática de historial al cambiar contexto
    \item Preservación de scripts personalizados al actualizar JSON
    \item Merge inteligente de cambios parciales
\end{itemize}

\textbf{D) Comandos Especiales:}

\textbf{1. Comando /icon:}
\begin{itemize}
    \item Sintaxis: \texttt{/icon descripción del icono [\#color]}
    \item Detecta colores hexadecimales en el prompt
    \item Traduce automáticamente al inglés
    \item Genera 4 versiones de la imagen: Original, Fondo blanco, Transparente, Color personalizado
    \item Descarga automática de todas las versiones
    \item Actualiza JSON con imagenKey para referencia
\end{itemize}

\textbf{2. Comando /code:}
\begin{itemize}
    \item Sintaxis: \texttt{/code descripción del código}
    \item Genera código JavaScript o SQL según contexto
    \item Extrae bloques de código de la respuesta
    \item Callback automático para insertar en editor
    \item Soporta scripts de elementos, listas, entidades
\end{itemize}

\textbf{3. Comando /ticket:}
\begin{itemize}
    \item Sintaxis: \texttt{/ticket descripción del ticket}
    \item Genera código de impresión de tickets
    \item Soporta múltiples formatos (TSPL, ESCPOS, ZPL, etc.)
    \item Extrae y envía código al editor de tickets
\end{itemize}

\textbf{E) Registro de Uso y Costos:}

El sistema implementa un registro completo de uso de IA para análisis y facturación:

\textbf{1. Métricas Registradas:}
\begin{itemize}
    \item Usuario (username de Cognito)
    \item Modelo utilizado
    \item Tokens de entrada y salida
    \item Costo calculado en USD
    \item Timestamp de la operación
    \item Contexto de la operación
    \item Esquema de trabajo (espacio de Irakani)
\end{itemize}

\textbf{2. Almacenamiento:}
\begin{itemize}
    \item DynamoDB: Tabla 'irakani-builder-usage-logs'
    \item Partition Key: userId
    \item Sort Key: timestamp
    \item TTL: 90 días (configurable)
\end{itemize}

\textbf{3. Cálculo de Costos:}
\begin{lstlisting}[caption={Cálculo de costos de uso de IA}]
inputCost = (inputTokens / 1000) * precioInput
outputCost = (outputTokens / 1000) * precioOutput
costoTotal = inputCost + outputCost
\end{lstlisting}

\textbf{4. Dashboard de Uso:}
\begin{itemize}
    \item Componente UsageDashboard en SpaceMenu
    \item Visualización de tokens consumidos
    \item Costos por modelo y período
    \item Gráficos de tendencias
    \item Exportación de reportes
\end{itemize}

\textbf{F) Optimizaciones Implementadas:}

\textbf{1. Caché de Prompts:}
\begin{itemize}
    \item Los system prompts se cachean por contexto
    \item Evita regeneración en mensajes subsecuentes
    \item Reduce latencia y tokens consumidos
    \item Se limpia al cambiar de contexto
\end{itemize}

\textbf{2. Historial Limitado:}
\begin{itemize}
    \item Máximo 20 mensajes por conversación
    \item Previene crecimiento excesivo de contexto
    \item Reduce costos de tokens de entrada
    \item Mantiene relevancia de la conversación
\end{itemize}

\textbf{3. Contextos Resumidos:}
\begin{itemize}
    \item Función createResumedContext() para JSON grandes
    \item Incluye solo información esencial
    \item Reduce tokens de entrada significativamente
    \item Mantiene funcionalidad completa
\end{itemize}

\textbf{4. Streaming Optimizado:}
\begin{itemize}
    \item Server-Sent Events para respuestas en tiempo real
    \item Renderizado progresivo en UI
    \item Mejor experiencia de usuario
    \item Permite cancelación de operaciones
\end{itemize}

\textbf{G) Manejo de Errores y Resiliencia:}

\textbf{1. Errores de Red:}
\begin{itemize}
    \item Reintentos automáticos con backoff exponencial
    \item Mensajes de error descriptivos al usuario
    \item Fallback a modo sin streaming si falla
\end{itemize}

\textbf{2. Errores de Parsing:}
\begin{itemize}
    \item Validación de JSON antes de aplicar
    \item Preservación del estado anterior si falla
    \item Mensajes claros sobre qué falló
\end{itemize}

\textbf{3. Tokens Expirados:}
\begin{itemize}
    \item Detección automática de sesiones expiradas
    \item Redirección a login cuando es necesario
    \item Preservación del trabajo en progreso
\end{itemize}

\textbf{4. Límites de Rate:}
\begin{itemize}
    \item Manejo de errores 429 (Too Many Requests)
    \item Mensajes informativos al usuario
    \item Sugerencias de espera
\end{itemize}

\textbf{H) Seguridad y Privacidad:}

\textbf{1. Autenticación:}
\begin{itemize}
    \item Todos los endpoints requieren usuario autenticado
    \item Header 'x-user-id' en todas las peticiones
    \item Validación de sesión en backend
\end{itemize}

\textbf{2. Aislamiento de Datos:}
\begin{itemize}
    \item Cada usuario tiene su propio historial
    \item Contextos separados por aplicación
    \item Esquemas de trabajo aislados (espacios de Irakani)
\end{itemize}

\textbf{3. Sanitización:}
\begin{itemize}
    \item Limpieza de prompts antes de enviar a Bedrock
    \item Validación de JSON recibido
    \item Protección contra inyección de prompts
\end{itemize}

\textbf{4. Auditoría:}
\begin{itemize}
    \item Registro completo de todas las operaciones
    \item Trazabilidad por usuario y timestamp
    \item Análisis de patrones de uso
\end{itemize}

Esta arquitectura proporciona una integración robusta, escalable y eficiente con AWS Bedrock, permitiendo a Irakani Builder ofrecer capacidades de IA generativa de clase empresarial mientras mantiene control sobre costos, seguridad y experiencia de usuario.


\subsubsection{Diseño de la Interfaz de Usuario (UI/UX)}

Irakani Builder implementa una interfaz de usuario moderna y profesional basada en React 18 con TypeScript, diseñada para maximizar la productividad del desarrollador mediante una arquitectura de paneles modulares y redimensionables. La UI sigue principios de diseño centrado en el usuario, con énfasis en la eficiencia del flujo de trabajo y la accesibilidad de las herramientas de IA.

\textbf{A) Arquitectura de Componentes y Flujo de Navegación:}

El sistema implementa un flujo de autenticación y navegación multi-nivel que guía al usuario desde el login hasta el entorno de desarrollo completo:

\textbf{1. Flujo de Autenticación (AuthComponent):}

La Figura \ref{fig:ui_login} muestra la interfaz de autenticación implementada con AWS Cognito, que incluye:

\begin{itemize}
    \item Login/Registro con validación de credenciales
    \item Verificación de código 2FA para seguridad adicional
    \item Recuperación de contraseña mediante email
    \item Gestión de sesiones persistentes con Valkey
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{imagenes/4.2.4-login.png}
    \caption{Interfaz de autenticación de Irakani Builder}
    \label{fig:ui_login}
\end{figure}

\textbf{2. Selección de Modo de Acceso (AccessSelection):}

Después de autenticarse, el usuario puede elegir entre dos modos de trabajo, como se muestra en la Figura \ref{fig:ui_access_selection}:

\begin{itemize}
    \item \textbf{Builder Mode:} Acceso directo al constructor de aplicaciones sin dependencias externas
    \item \textbf{Irakani Spaces:} Integración con espacios de trabajo de la plataforma Irakani para sincronización de datos
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{imagenes/4.2.4-access-selection.png}
    \caption{Selección de modo de acceso al Builder}
    \label{fig:ui_access_selection}
\end{figure}


\textbf{3. Selección de Espacio (SpaceSelection):}

Para usuarios que eligen el modo Irakani Spaces, la Figura \ref{fig:ui_space_selection} muestra la interfaz de selección de espacios de trabajo:

\begin{itemize}
    \item Lista de espacios disponibles del usuario
    \item Información de cada espacio (nombre, descripción, última modificación)
    \item Selección de espacio de trabajo activo
    \item Creación de nuevos espacios
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{imagenes/4.2.4-space-selection.png}
    \caption{Selección de espacio de trabajo en Irakani}
    \label{fig:ui_space_selection}
\end{figure}

\textbf{4. Menú de Navegación de Espacios:}

Una vez seleccionado un espacio de trabajo, el usuario tiene acceso a un menú de navegación que organiza las diferentes secciones del espacio Irakani. Este menú proporciona acceso rápido a las funcionalidades principales del espacio:

\textbf{a) Menú de Aplicaciones:}

La Figura \ref{fig:ui_space_menu_aplicaciones} muestra el menú de aplicaciones disponibles en el espacio:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{imagenes/4.2.4-space-menu-aplicaciones.png}
    \caption{Menú de aplicaciones del espacio Irakani}
    \label{fig:ui_space_menu_aplicaciones}
\end{figure}

\textbf{b) Menú de Base de Datos:}

La Figura \ref{fig:ui_space_menu_database} muestra el menú de gestión de bases de datos:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{imagenes/4.2.4-space-menu-database.png}
    \caption{Menú de base de datos del espacio Irakani}
    \label{fig:ui_space_menu_database}
\end{figure}

\textbf{c) Menú de Listas:}

La Figura \ref{fig:ui_space_menu_listas} muestra el menú de gestión de listas de datos:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{imagenes/4.2.4-space-menu-listas.png}
    \caption{Menú de listas del espacio Irakani}
    \label{fig:ui_space_menu_listas}
\end{figure}

\textbf{d) Menú de Perfiles:}

La Figura \ref{fig:ui_space_menu_perfiles} muestra el menú de gestión de perfiles de usuario:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{imagenes/4.2.4-space-menu-perfiles.png}
    \caption{Menú de perfiles del espacio Irakani}
    \label{fig:ui_space_menu_perfiles}
\end{figure}

\textbf{e) Menú de Entidades:}

La Figura \ref{fig:ui_space_menu_entidades} muestra el menú de gestión de entidades de datos:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{imagenes/4.2.4-space-menu-entidades.png}
    \caption{Menú de entidades del espacio Irakani}
    \label{fig:ui_space_menu_entidades}
\end{figure}

Estos menús permiten al usuario navegar entre las diferentes secciones del espacio de trabajo, facilitando el acceso a las funcionalidades de gestión de aplicaciones, bases de datos, listas, perfiles y entidades. La integración con el espacio Irakani permite sincronizar automáticamente los datos entre el Builder y la plataforma principal.

\vspace{0.5cm}

\textbf{5. Gestión de Sesiones:}

El sistema permite trabajar con múltiples sesiones simultáneas, como se observa en la Figura \ref{fig:ui_sesiones}. Cada sesión representa un proyecto o aplicación independiente:

\begin{itemize}
    \item Creación de nuevas sesiones de trabajo
    \item Cambio entre sesiones existentes
    \item Eliminación de sesiones con confirmación
    \item Aislamiento completo de datos por sesión
    \item Persistencia automática en Valkey
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{imagenes/4.2.4-sesiones.png}
    \caption{Gestión de sesiones de trabajo}
    \label{fig:ui_sesiones}
\end{figure}


\textbf{B) Diseño del Builder Principal (Layout de 3 Paneles):}
 Tab Código
La interfaz del Builder se organiza en una arquitectura de tres paneles principales redimensionables, optimizada para el flujo de trabajo del desarrollador. La Figura \ref{fig:ui_builder_completo} muestra la vista completa del Builder:

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{imagenes/4.2.4-builder-completo.png}
    \caption{Vista completa del Builder con arquitectura de 3 paneles}
    \label{fig:ui_builder_completo}
\end{figure}

\textbf{C) Panel Izquierdo (Left Panel) - 350px (redimensionable 300-450px):}

El panel izquierdo proporciona acceso a las funcionalidades de generación y gestión de aplicaciones, como se muestra en la Figura \ref{fig:ui_panel_izquierdo}:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{imagenes/4.2.4-panel-izquierdo.png}
    \caption{Panel izquierdo con generador de aplicaciones}
    \label{fig:ui_panel_izquierdo}
\end{figure}

\textbf{1. Tab Generador (AppGenerator):}

Componentes principales:
\begin{itemize}
    \item Campo de texto multi-línea para descripción de la aplicación en lenguaje natural
    \item Selector de tipo de aplicación (WEB/MÓVIL)
    \item Botón "Generar Aplicación" con indicador de carga
    \item Visualización de estado del workflow (Step Functions)
    \item Indicadores de progreso de generación en tiempo real
\end{itemize}

Funcionalidad:
\begin{itemize}
    \item Generación de aplicaciones mediante IA (AWS Bedrock)
    \item Integración con Step Functions para procesamiento asíncrono
    \item Guardado automático del prompt en Valkey
    \item Validación de entrada antes de enviar a la IA
\end{itemize}

La Figura \ref{fig:ui_flujo_generacion} ilustra el flujo completo de generación de aplicaciones:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{imagenes/4.2.4-flujo-generacion.png}
    \caption{Flujo de generación de aplicaciones con IA}
    \label{fig:ui_flujo_generacion}
\end{figure}


\textbf{2. Características del Panel Izquierdo:}

\begin{itemize}
    \item Colapsable con botón toggle para maximizar espacio de trabajo
    \item Redimensionable con drag handle entre 300-450px
    \item Zoom con Ctrl+Scroll para ajustar tamaño de fuente
    \item Persistencia de estado (tamaño, tab activo) en Valkey
\end{itemize}

\textbf{D) Panel Central (Main Editor) - Ancho flexible:}

El panel central es el área principal de trabajo, dividida en dos secciones verticales:

\textbf{1. Tree View (JsonTreeView) - 250px (redimensionable 200-500px):}

La Figura \ref{fig:ui_tree_view} muestra el árbol jerárquico de navegación de la estructura JSON:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.35\textwidth]{imagenes/4.2.4-tree-view.png}
    \caption{Tree View para navegación de estructura JSON}
    \label{fig:ui_tree_view}
\end{figure}

Componentes del Tree View:
\begin{itemize}
    \item Árbol jerárquico del JSON de la aplicación
    \item Iconos diferenciados por tipo de nodo (aplicación, forma, elemento, lista, perfil, entidad)
    \item Indicadores de expansión/colapso para navegación eficiente
    \item Resaltado del elemento seleccionado
    \item Badges con contadores de elementos hijos
\end{itemize}

Funcionalidad:
\begin{itemize}
    \item Navegación por la estructura completa de la aplicación
    \item Selección de elementos para edición en el panel derecho
    \item Expansión automática de nodos padres al seleccionar un hijo
    \item Búsqueda de nodos por nombre o tipo
    \item Sincronización bidireccional con el editor de código
\end{itemize}


Estructura visualizada en el Tree View:

\begin{verbatim}
[APP] Aplicacion
  +-- [FORM] Formas
      +-- [FORM] Forma 1
          +-- [INPUT] Elemento 1 (input)
          +-- [SELECT] Elemento 2 (select)
          +-- [FORM] Subforma
      +-- [FORM] Forma 2
  +-- [DEPS] Dependencias
      +-- [LIST] Listas
          +-- Lista 1
          +-- Lista 2
      +-- [USER] Perfiles
      +-- [DB] Entidades
      +-- [FLOW] Workflows
  +-- [GEAR] Configuracion
\end{verbatim}

\textbf{2. Tabs de Edición:}

\textbf{a) Tab Visual (EditorVisual):}

La Figura \ref{fig:ui_editor_visual} muestra el editor visual para diseño de formularios:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{imagenes/4.2.4-editor-visual.png}
    \caption{Editor visual de formularios}
    \label{fig:ui_editor_visual}
\end{figure}

Características del editor visual:
\begin{itemize}
    \item Selector de tipo de elemento (input, select, button, checkbox, radio, textarea, etc.)
    \item Configuración de propiedades generales (id, nombre, etiqueta, placeholder)
    \item Propiedades específicas por tipo de elemento
    \item Validaciones configurables (requerido, longitud, formato)
    \item Preview en tiempo real del formulario
\end{itemize}

Sub-editores especializados:
\begin{itemize}
    \item \textbf{AplicacionEditor:} Configuración de propiedades globales de la aplicación
    \item \textbf{ListasEditor:} Gestión de listas de datos y campos
    \item \textbf{PerfilesEditor:} Configuración de perfiles de usuario y permisos
    \item \textbf{EntidadesEditor:} Diseño de entidades de datos y relaciones
    \item \textbf{WorkflowsEditor:} Diseño de flujos de trabajo y procesos
\end{itemize}


\textbf{b) Tab Código (Monaco Editor):}

La Figura \ref{fig:ui_monaco_editor} muestra la integración del Monaco Editor para edición de código:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{imagenes/4.2.4-monaco-editor.png}
    \caption{Monaco Editor integrado con resaltado de sintaxis}
    \label{fig:ui_monaco_editor}
\end{figure}

Características del Monaco Editor:
\begin{itemize}
    \item Editor de código JSON con sintaxis highlighting avanzado
    \item Autocompletado inteligente basado en el esquema
    \item Validación en tiempo real con indicadores de errores
    \item Más de 20 temas personalizables (Monokai, Dracula, GitHub, Nord, etc.)
    \item Formateo automático con Prettier
    \item Búsqueda y reemplazo con expresiones regulares
    \item Minimap de navegación para archivos grandes
    \item Plegado de código (code folding)
    \item Múltiples cursores y selección rectangular
\end{itemize}

La Figura \ref{fig:ui_temas} muestra el selector de temas disponibles:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.2\textwidth]{imagenes/4.2.4-temas.png}
    \caption{Selector de temas del editor de código}
    \label{fig:ui_temas}
\end{figure}

Temas disponibles incluyen:
\begin{itemize}
    \item Temas claros: vs-light, github-light, solarized-light
    \item Temas oscuros: vs-dark, monokai, dracula, github-dark, one-dark, nord, cobalt, tomorrow-night
    \item Temas de alto contraste: hc-black, hc-light
    \item Temas especializados: material-theme, ayu-dark, ayu-light, y más
\end{itemize}


\textbf{c) Tab Chat (ChatInterface):}

La Figura \ref{fig:ui_chat_ia} muestra la interfaz de chat con el asistente de IA:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{imagenes/4.2.4-chat-ia.png}
    \caption{Interfaz de chat con asistente de IA}
    \label{fig:ui_chat_ia}
\end{figure}

Características del chat con IA:
\begin{itemize}
    \item Interfaz de conversación con historial persistente
    \item Selector de contexto (aplicación completa, listas, entidades, elemento seleccionado)
    \item Selector de templates de prompts predefinidos
    \item Streaming de respuestas en tiempo real
    \item Aplicación automática de cambios sugeridos al JSON
    \item Indicadores de tokens consumidos y costos estimados
    \item Soporte para código en las respuestas con syntax highlighting
    \item Botones de acción rápida (Aplicar, Copiar, Regenerar)
\end{itemize}

Funcionalidades del Chat:
\begin{itemize}
    \item Generación de código para nuevos componentes
    \item Explicación de estructuras existentes
    \item Sugerencias de mejora y optimización
    \item Corrección de errores de sintaxis o lógica
    \item Optimización de consultas y validaciones
    \item Traducción entre formatos de datos
\end{itemize}

\textbf{d) Tab Preview (FormPreview):}

La Figura \ref{fig:ui_preview} muestra la vista previa de formularios:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{imagenes/4.2.4-preview.png}
    \caption{Vista previa de formularios renderizados}
    \label{fig:ui_preview}
\end{figure}


Características del Preview:
\begin{itemize}
    \item Renderizado en tiempo real de formularios
    \item Simulación de interacciones de usuario
    \item Validación de campos según reglas definidas
    \item Visualización de mensajes de error
    \item Diseño resposivo (web, movil)
    \item Modo de prueba interactivo
\end{itemize}

\textbf{3. Características del Panel Central:}

\begin{itemize}
    \item Tabs dinámicos según contexto del elemento seleccionado
    \item Indicador visual de guardado en progreso
    \item Historial de cambios con undo/redo
    \item Redimensionamiento del Tree View con drag handle
\end{itemize}

\textbf{E) Panel Derecho (Right Panel) - 400px (redimensionable 350-600px):}

El panel derecho proporciona acceso contextual a propiedades, asistencia de IA y herramientas de análisis.

\textbf{1. Tab Propiedades (PropertiesPanel):}

La Figura \ref{fig:ui_propiedades} muestra el panel de propiedades contextual:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{imagenes/4.2.4-propiedades.png}
    \caption{Panel de propiedades contextual}
    \label{fig:ui_propiedades}
\end{figure}


Paneles especializados según elemento seleccionado:

\textbf{a) AplicacionPropertiesPanel:}
\begin{itemize}
    \item Nombre de la aplicación
    \item Descripción detallada
\end{itemize}

\textbf{b) ElementosPropertiesPanel:}
\begin{itemize}
    \item Propiedades generales (id, nombre, etiqueta, placeholder)
    \item Propiedades específicas por tipo (opciones de select, formato de input, etc.)
    \item Validaciones (requerido, longitud mínima/máxima, patrón regex)
    \item Eventos y acciones (onChange, onClick, onBlur)
\end{itemize}

\textbf{c) ListasPropertiesPanel:}
\begin{itemize}
    \item Nombre de la lista
    \item Campos de la lista con tipos de datos
    \item Validaciones por campo
    \item Valores por defecto
    \item Integración con API Irakani
    \item Configuración de sincronización
\end{itemize}

\textbf{d) EntidadesPropertiesPanel:}
\begin{itemize}
    \item Nombre de la entidad
    \item Campos de la entidad
    \item Índices y claves primarias/foráneas
    \item Permisos de acceso por perfil
\end{itemize}

\textbf{2. Tab Estadísticas (JSONStatsPanel):}

La Figura \ref{fig:ui_estadisticas} muestra el panel de estadísticas y métricas:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{imagenes/4.2.4-estadisticas.png}
    \caption{Panel de estadísticas y métricas de uso}
    \label{fig:ui_estadisticas}
\end{figure}


Métricas mostradas:
\begin{itemize}
    \item Tamaño del JSON en bytes y KB
    \item Número total de elementos por tipo
    \item Complejidad de la aplicación
    \item Tiempo de generación promedio
\end{itemize}

\textbf{3. Características del Panel Derecho:}

\begin{itemize}
    \item Contenido contextual según elemento seleccionado
    \item Redimensionable entre 350-600px
    \item Colapsable para maximizar espacio de edición
    \item Persistencia de estado en Valkey
\end{itemize}

\textbf{F) Componentes Especializados:}

\textbf{1. DB Admin (DBAdmin):}

La Figura \ref{fig:ui_db_admin} muestra el administrador de bases de datos integrado:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{imagenes/4.2.4-db-admin.png}
    \caption{Administrador de bases de datos con asistente de IA}
    \label{fig:ui_db_admin}
\end{figure}

Características del DB Admin:
\begin{itemize}
    \item Gestión de conexiones a múltiples bases de datos (MySQL, SQL Server)
    \item Explorador de tablas y esquemas con navegación jerárquica
    \item Editor de consultas SQL con autocompletado
    \item Visualización de resultados en tabla con paginación
    \item Asistente de IA para generación de queries desde lenguaje natural
    \item Historial de consultas ejecutadas
    \item Análisis de planes de ejecución
\end{itemize}


\textbf{2. Generador de Iconos (Icon Generator):}

La Figura \ref{fig:ui_generador_iconos} muestra el generador de iconos con IA:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{imagenes/4.2.4-generador-iconos.png}
    \caption{Generador de iconos con Titan Image Generator}
    \label{fig:ui_generador_iconos}
\end{figure}

Características del generador de iconos:
\begin{itemize}
    \item Prompt en español con traducción automática al inglés
    \item Generación con Amazon Titan Image Generator
    \item Personalización de colores con selector de paleta
    \item Almacenamiento automático en S3
    \item Historial de iconos generados
    \item Ajuste de tamaño y resolución
\end{itemize}

\textbf{3. Sistema de Notificaciones (NotificationSystem):}

La Figura \ref{fig:ui_notificaciones} muestra el sistema de notificaciones toast:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{imagenes/4.2.4-notificaciones.png}
    \caption{Sistema de notificaciones no intrusivas}
    \label{fig:ui_notificaciones}
\end{figure}

Características de las notificaciones:
\begin{itemize}
    \item Notificaciones toast no intrusivas en esquina superior derecha
    \item Tipos diferenciados: success, error, warning, info, loading
    \item Confirmaciones con callbacks para acciones críticas
    \item Auto-dismiss configurable (2-10 segundos)
    \item Stack de notificaciones con límite de 5 simultáneas
    \item Animaciones suaves de entrada/salida
    \item Iconos contextuales por tipo
    \item Botón de cierre manual
\end{itemize}


\textbf{G) Características de Experiencia de Usuario:}

\textbf{1. Paneles Redimensionables:}

La Figura \ref{fig:ui_redimensionable} muestra los paneles que pueden ajustarse de tamaño:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{imagenes/4.2.4-redimensionable.png}
    \caption{Paneles con tamaño ajustable}
    \label{fig:ui_redimensionable}
\end{figure}

Los paneles pueden redimensionarse arrastrando sus bordes, y el tamaño se guarda automáticamente para cada usuario.

\textbf{2. Guardado Automático:}

El sistema guarda los cambios automáticamente cada medio segundo. Se muestra un indicador visual del estado (guardando, guardado o error) y se previene la pérdida de datos al cerrar la aplicación.

\textbf{3. Navegación:}

\begin{itemize}
    \item El elemento seleccionado se resalta en todos los paneles
    \item Atajos de teclado: Ctrl+Z (deshacer), Ctrl+Y (rehacer), Ctrl+F (buscar)
\end{itemize}

\textbf{4. Indicadores Visuales:}

\begin{itemize}
    \item Barras de progreso durante la carga
    \item Tooltips informativos al pasar el cursor
    \item Colores diferentes para cada estado (activo, deshabilitado, etc.)
\end{itemize}

\textbf{5. Diseño Adaptable:}

La interfaz se adapta a diferentes tamaños de pantalla, colapsando paneles automáticamente en pantallas pequeñas para mantener la usabilidad.

\textbf{6. Accesibilidad:}

Se puede navegar completamente usando el teclado (Tab, Enter, Escape) y la interfaz es compatible con lectores de pantalla.


\textbf{H) Flujos de Trabajo Principales:}

Los flujos de trabajo principales del sistema se documentan en detalle en la subsección 4.3.6 ``Diagramas de Flujo y Casos de Uso'', donde se presentan tanto los diagramas de flujo como los casos de uso detallados que describen las interacciones del sistema.

\textbf{I) Principios de Diseño Aplicados:}

La interfaz de Irakani Builder se diseñó siguiendo principios fundamentales de usabilidad y experiencia de usuario, implementados de manera práctica en cada componente del sistema:

\textbf{1. Consistencia Visual:} Se estableció un sistema de diseño unificado utilizando una paleta de colores coherente con efectos glassmorphism, tipografía Inter para la interfaz y JetBrains Mono para el código, y un espaciado sistemático basado en múltiplos de 8px. Esto garantiza que todos los elementos visuales mantengan una apariencia profesional y predecible.

\textbf{2. Jerarquía de Información:} Los elementos se organizaron por importancia visual, destacando las funciones principales con mayor tamaño y contraste. Se implementaron paneles colapsables y agrupación lógica de funciones relacionadas para optimizar el espacio disponible y facilitar la navegación.

\textbf{3. Eficiencia del Flujo de Trabajo:} Se minimizó el número de clics necesarios para tareas comunes mediante acciones contextuales y navegación por pestañas (Visual, Código, Chat, Scripts). Las operaciones asíncronas incluyen indicadores de progreso claros para mantener al usuario informado.

\textbf{4. Prevención de Errores:} Se implementó validación en tiempo real de campos de entrada, confirmaciones para acciones destructivas, y mensajes de error descriptivos con sugerencias de solución. El editor Monaco valida la sintaxis JSON automáticamente, y el sistema maneja tokens expirados con redirección automática al login.

\textbf{5. Retroalimentación Inmediata:} Cada interacción del usuario recibe respuesta visual instantánea mediante un sistema de notificaciones toast diferenciado (éxito, error, advertencia, información, carga) y animaciones suaves con Framer Motion. Los estados de carga se diferencian según la operación (guardando, exportando, generando).

\textbf{J) Objetivos de Métricas de Usabilidad:}

\begin{itemize}
    \item \textbf{Tiempo de aprendizaje:} Objetivo de que usuarios nuevos puedan generar su primera aplicación en menos de 5 minutos
    \item \textbf{Eficiencia:} Meta de reducción del 70\% en tiempo de desarrollo comparado con codificación manual
    \item \textbf{Tasa de error:} Objetivo de menos del 5\% de operaciones resulten en errores gracias a validación en tiempo real
    \item \textbf{Satisfacción:} Meta de score promedio de 4.5/5 en encuestas de usabilidad
    \item \textbf{Retención:} Objetivo de 90\% de usuarios continúen usando la plataforma después de la primera semana
\end{itemize}

Esta arquitectura de UI/UX proporciona una experiencia de desarrollo profesional, intuitiva y eficiente, aprovechando las capacidades de IA para acelerar el proceso de construcción de aplicaciones mientras mantiene el control total del desarrollador sobre el resultado final.

\subsubsection{Diagramas de Flujo y Casos de Uso}

A continuación se presentan los diagramas de flujo de trabajo principales del sistema, seguidos de casos de uso detallados que describen las interacciones críticas entre el usuario, la interfaz y el motor de IA.

\textbf{Caso de Uso 1: Generación de Componentes con IA}

\textbf{Actor:} Desarrollador

\textbf{Descripción:} El usuario solicita la creación de un elemento de interfaz específico mediante lenguaje natural, aprovechando las capacidades de AWS Bedrock para generar automáticamente la estructura JSON del componente.

\textbf{Flujo Principal:}

\begin{enumerate}
    \item El usuario selecciona un contenedor existente en el Editor Visual donde desea agregar el nuevo componente
    \item Ingresa una descripción en lenguaje natural en el chat de IA (ejemplo: ``Botón con icono de impresión'')
    \item El sistema captura el contexto actual del contenedor seleccionado, incluyendo:
    \begin{itemize}
        \item Estructura JSON actual del formulario
        \item Componentes hermanos existentes
        \item Propiedades del contenedor padre
    \end{itemize}
    \item El sistema construye un prompt optimizado combinando:
    \begin{itemize}
        \item La descripción del usuario
        \item El contexto del contenedor
        \item Restricciones de validación
        \item Ejemplos de componentes similares (Few-shot learning)
    \end{itemize}
    \item El sistema envía la solicitud a AWS Bedrock utilizando el modelo Claude 4 Sonnet
    \item AWS Bedrock procesa el prompt y genera la estructura JSON del componente solicitado
    \item El sistema valida el JSON generado contra el esquema definido
    \item Si la validación es exitosa, el componente se inserta automáticamente en el contenedor seleccionado
    \item El Editor Visual renderiza el nuevo componente en tiempo real
    \item El sistema sincroniza la vista de código (Monaco Editor) con la estructura actualizada
    \item Se muestra una notificación de éxito al usuario
    \item El sistema guarda automáticamente el estado en Valkey (caché) y programa el guardado persistente en S3
\end{enumerate}

\textbf{Flujos Alternativos:}

\begin{itemize}
    \item \textbf{FA1 - Error de Bedrock:} Si AWS Bedrock no responde o devuelve un error, el sistema muestra un mensaje descriptivo y sugiere reformular la solicitud
    \item \textbf{FA2 - Timeout:} Si la generación excede 30 segundos, se cancela la operación y se notifica al usuario
\end{itemize}

\textbf{Postcondiciones:}
\begin{itemize}
    \item El componente generado está visible en el Editor Visual
    \item El JSON actualizado está sincronizado en todas las vistas
    \item El estado se ha guardado en Valkey para recuperación rápida
\end{itemize}

La Figura \ref{fig:ui_flujo_generacion} ilustra visualmente este proceso de generación asistida por IA, mientras que la Figura \ref{fig:seq_generacion_componentes} muestra el diagrama de secuencia detallado de las interacciones entre componentes.

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    node distance=0.3cm and 0.5cm,
    actor/.style={rectangle, draw, minimum width=2cm, minimum height=0.6cm, fill=blue!10, font=\footnotesize},
    message/.style={->, >=stealth, thick, font=\tiny},
    return/.style={->, >=stealth, dashed, font=\tiny}
]

% Actores
\node[actor] (user) {Usuario};
\node[actor, right=of user] (ui) {Editor Visual};
\node[actor, right=of ui] (chat) {Chat IA};
\node[actor, right=of chat] (backend) {Backend};
\node[actor, right=of backend] (bedrock) {AWS Bedrock};
\node[actor, right=of bedrock] (valkey) {Valkey};

% Líneas de vida
\draw[dashed] (user.south) -- ++(0,-10);
\draw[dashed] (ui.south) -- ++(0,-10);
\draw[dashed] (chat.south) -- ++(0,-10);
\draw[dashed] (backend.south) -- ++(0,-10);
\draw[dashed] (bedrock.south) -- ++(0,-10);
\draw[dashed] (valkey.south) -- ++(0,-10);

% Mensajes
\draw[message] ([yshift=-1cm]user.south) -- ([yshift=-1cm]ui.south) node[midway, above, font=\tiny] {1. Seleccionar contenedor};
\draw[message] ([yshift=-1.8cm]user.south) -- ([yshift=-1.8cm]chat.south) node[midway, above, font=\tiny] {2. Escribir prompt};
\draw[message] ([yshift=-2.6cm]chat.south) -- ([yshift=-2.6cm]ui.south) node[midway, above, font=\tiny] {3. Capturar contexto};
\draw[return] ([yshift=-3.2cm]ui.south) -- ([yshift=-3.2cm]chat.south) node[midway, below, font=\tiny] {Contexto JSON};
\draw[message] ([yshift=-4cm]chat.south) -- ([yshift=-4cm]backend.south) node[midway, above, font=\tiny] {4. Enviar solicitud};
\draw[message] ([yshift=-4.8cm]backend.south) -- ([yshift=-4.8cm]bedrock.south) node[midway, above, font=\tiny] {5. Generar componente};
\draw[return] ([yshift=-5.4cm]bedrock.south) -- ([yshift=-5.4cm]backend.south) node[midway, below, font=\tiny] {JSON componente};
\draw[return] ([yshift=-6.2cm]backend.south) -- ([yshift=-6.2cm]chat.south) node[midway, below, font=\tiny] {Componente validado};
\draw[message] ([yshift=-7cm]chat.south) -- ([yshift=-7cm]ui.south) node[midway, above, font=\tiny] {6. Insertar y renderizar};
\draw[message] ([yshift=-7.8cm]chat.south) -- ([yshift=-7.8cm]valkey.south) node[midway, above, font=\tiny] {7. Guardar estado};
\draw[return] ([yshift=-8.4cm]valkey.south) -- ([yshift=-8.4cm]chat.south) node[midway, below, font=\tiny] {Confirmación};
\draw[message] ([yshift=-9.2cm]ui.south) -- ([yshift=-9.2cm]user.south) node[midway, above, font=\tiny] {8. Notificar éxito};

\end{tikzpicture}
\caption{Diagrama de secuencia: Generación de Componentes con IA}
\label{fig:seq_generacion_componentes}
\end{figure}

\vspace{0.5cm}

\textbf{Caso de Uso 2: Conexión a Base de Datos Externa}

\textbf{Actor:} Desarrollador

\textbf{Descripción:} El usuario establece una conexión segura a una base de datos externa (MySQL o SQL Server) para integrar datos reales en las aplicaciones generadas, permitiendo operaciones de consulta y manipulación de datos.

\textbf{Precondiciones:}
\begin{itemize}
    \item El usuario tiene credenciales válidas de acceso a la base de datos
    \item La base de datos es accesible desde la red donde se ejecuta Irakani Builder
    \item El motor de base de datos es MySQL 5.7+ o SQL Server 2016+
\end{itemize}

\textbf{Flujo Principal:}

\begin{enumerate}
    \item El usuario accede al panel ``DB Admin'' desde el menú de la aplicación
    \item El sistema presenta el formulario de configuración de conexión con los siguientes campos:
    \begin{itemize}
        \item Motor de base de datos (MySQL / SQL Server)
        \item Host (dirección IP o nombre de dominio)
        \item Puerto ([PUERTO_CENSURADO] para MySQL, [PUERTO_CENSURADO] para SQL Server por defecto)
        \item Nombre de la base de datos
        \item Usuario
        \item Contraseña (campo enmascarado)
    \end{itemize}
    \item El usuario selecciona el motor de base de datos apropiado del dropdown
    \item Ingresa las credenciales de conexión en los campos correspondientes
    \item Hace clic en el botón ``Conectar''
    \item El sistema valida que todos los campos requeridos estén completos
    \item El backend establece una conexión de prueba utilizando el pool de conexiones configurado
    \item Si la conexión es exitosa:
    \begin{itemize}
        \item Almacena el token de conexión encriptado en la sesión del usuario
        \item Consulta el esquema de la base de datos para obtener la lista de tablas
        \item Recupera los metadatos de cada tabla (columnas, tipos de datos, claves primarias)
    \end{itemize}
    \item El sistema muestra la lista de tablas disponibles en el panel lateral izquierdo
    \item Para cada tabla, se presenta:
    \begin{itemize}
        \item Nombre de la tabla
        \item Número de columnas
        \item Icono indicador del tipo de tabla
        \item Opción de expandir para ver columnas
    \end{itemize}
    \item El usuario puede hacer clic en una tabla para:
    \begin{itemize}
        \item Ver su estructura completa
        \item Ejecutar consultas SQL
        \item Utilizar el asistente de IA para generar queries en lenguaje natural
    \end{itemize}
    \item La conexión permanece activa durante la sesión del usuario
    \item El sistema mantiene un heartbeat cada 5 minutos para verificar la conexión
\end{enumerate}

\textbf{Flujos Alternativos:}

\begin{itemize}
    \item \textbf{FA1 - Credenciales Inválidas:} Si las credenciales son incorrectas, el sistema muestra un mensaje de error específico (``Usuario o contraseña incorrectos'') y permite reintentar
    \item \textbf{FA2 - Host Inaccesible:} Si no se puede alcanzar el host, se muestra un error de timeout con sugerencias de verificación de red
    \item \textbf{FA3 - Permisos Insuficientes:} Si el usuario de base de datos no tiene permisos para listar tablas, se muestra un mensaje indicando la necesidad de permisos SELECT en INFORMATION\_SCHEMA
    \item \textbf{FA4 - Conexión Perdida:} Si la conexión se pierde durante la sesión, el sistema detecta el fallo en el siguiente heartbeat y solicita reconexión
\end{itemize}

\textbf{Postcondiciones:}
\begin{itemize}
    \item La conexión a la base de datos está establecida y activa
    \item La lista de tablas está disponible para consulta
    \item El usuario puede ejecutar operaciones SQL sobre la base de datos conectada
\end{itemize}

\textbf{Consideraciones de Seguridad:}
\begin{itemize}
    \item Las conexiones utilizan SSL/TLS cuando está disponible
    \item Los tokens de sesión expiran después de 4 horas de inactividad
    \item Se implementa rate limiting para prevenir ataques de fuerza bruta
    \item Todas las queries se ejecutan con prepared statements para prevenir SQL injection
\end{itemize}

La Figura \ref{fig:ui_db_admin} muestra la interfaz del administrador de bases de datos con una conexión activa y la lista de tablas disponibles, mientras que la Figura \ref{fig:seq_conexion_bd} presenta el diagrama de secuencia del proceso de conexión.

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    node distance=0.5cm and 1.2cm,
    actor/.style={rectangle, draw, minimum width=1.8cm, minimum height=0.6cm, fill=green!10, font=\footnotesize},
    message/.style={->, >=stealth, thick, font=\tiny},
    return/.style={->, >=stealth, dashed, font=\tiny}
]

% Actores
\node[actor] (user) {Usuario};
\node[actor, right=of user] (ui) {DB Admin UI};
\node[actor, right=of ui] (backend) {Backend};
\node[actor, right=of backend] (valkey) {Valkey};
\node[actor, right=of valkey] (dbservice) {DB Service};
\node[actor, right=of dbservice] (db) {Base de Datos};

% Líneas de vida
\draw[dashed] (user.south) -- ++(0,-12);
\draw[dashed] (ui.south) -- ++(0,-12);
\draw[dashed] (backend.south) -- ++(0,-12);
\draw[dashed] (valkey.south) -- ++(0,-12);
\draw[dashed] (dbservice.south) -- ++(0,-12);
\draw[dashed] (db.south) -- ++(0,-12);

% Mensajes
\draw[message] ([yshift=-1cm]user.south) -- ([yshift=-1cm]ui.south) node[midway, above, font=\tiny] {1. Abrir DB Admin};
\draw[message] ([yshift=-1.8cm]user.south) -- ([yshift=-1.8cm]ui.south) node[midway, above, font=\tiny] {2. Ingresar credenciales};
\draw[message] ([yshift=-2.6cm]ui.south) -- ([yshift=-2.6cm]backend.south) node[midway, above, font=\tiny] {3. Enviar conexión};
\draw[message] ([yshift=-3.4cm]backend.south) -- ([yshift=-3.4cm]dbservice.south) node[midway, above, font=\tiny] {4. Conectar};
\draw[message] ([yshift=-4.2cm]dbservice.south) -- ([yshift=-4.2cm]db.south) node[midway, above, font=\tiny] {5. Probar conexión};
\draw[return] ([yshift=-4.8cm]db.south) -- ([yshift=-4.8cm]dbservice.south) node[midway, below, font=\tiny] {Conexión OK};
\draw[message] ([yshift=-5.6cm]backend.south) -- ([yshift=-5.6cm]valkey.south) node[midway, above, font=\tiny] {6. Guardar sesión};
\draw[return] ([yshift=-6.2cm]valkey.south) -- ([yshift=-6.2cm]backend.south) node[midway, below, font=\tiny] {Sesión guardada};
\draw[message] ([yshift=-6.8cm]backend.south) -- ([yshift=-6.8cm]dbservice.south) node[midway, above, font=\tiny] {7. Consultar esquema};
\draw[message] ([yshift=-7.6cm]dbservice.south) -- ([yshift=-7.6cm]db.south) node[midway, above, font=\tiny] {8. SELECT tablas};
\draw[return] ([yshift=-8.2cm]db.south) -- ([yshift=-8.2cm]dbservice.south) node[midway, below, font=\tiny] {Lista tablas};
\draw[return] ([yshift=-9cm]dbservice.south) -- ([yshift=-9cm]backend.south) node[midway, below, font=\tiny] {Metadatos};
\draw[return] ([yshift=-9.8cm]backend.south) -- ([yshift=-9.8cm]ui.south) node[midway, below, font=\tiny] {Datos tablas};
\draw[message] ([yshift=-10.6cm]ui.south) -- ([yshift=-10.6cm]user.south) node[midway, above, font=\tiny] {9. Mostrar tablas};

\end{tikzpicture}
\caption{Diagrama de secuencia: Conexión a Base de Datos Externa}
\label{fig:seq_conexion_bd}
\end{figure}

\vspace{0.5cm}

\textbf{Caso de Uso 3: Edición Visual de Componentes}

\textbf{Actor:} Desarrollador

\textbf{Descripción:} El usuario modifica las propiedades de un componente existente utilizando el panel de propiedades contextual, permitiendo ajustes precisos sin necesidad de editar código manualmente.

\textbf{Flujo Principal:}

\begin{enumerate}
    \item El usuario hace clic sobre un componente en el Editor Visual
    \item El sistema resalta el componente seleccionado con un borde distintivo
    \item El panel de propiedades se actualiza automáticamente mostrando las propiedades editables del componente:
    \begin{itemize}
        \item Propiedades básicas (label, placeholder, valor por defecto)
        \item Propiedades de validación (requerido, patrón, longitud)
        \item Propiedades de comportamiento (deshabilitado, solo lectura)
    \end{itemize}
    \item El usuario modifica una o más propiedades utilizando los controles apropiados (inputs, selects, color pickers, toggles)
    \item Cada cambio se refleja instantáneamente en la vista previa del componente
    \item El sistema valida los valores ingresados en tiempo real
    \item Si un valor es inválido, se muestra un indicador visual y un mensaje de error
    \item Una vez que el usuario termina de editar, el sistema espera 500ms de inactividad (debounce)
    \item El sistema actualiza el JSON subyacente con los nuevos valores
    \item Se sincroniza la vista de código (Monaco Editor) con los cambios
    \item El estado actualizado se guarda automáticamente en Valkey
    \item Se muestra una notificación sutil indicando ``Cambios guardados''
\end{enumerate}

\textbf{Postcondiciones:}
\begin{itemize}
    \item Las propiedades del componente están actualizadas
    \item La vista previa refleja los cambios realizados
    \item El JSON está sincronizado en todas las vistas
    \item Los cambios están persistidos en caché
\end{itemize}

La Figura \ref{fig:seq_edicion_visual} ilustra el diagrama de secuencia de la edición visual de componentes con actualización en tiempo real.

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    node distance=0.5cm and 1.2cm,
    actor/.style={rectangle, draw, minimum width=1.8cm, minimum height=0.6cm, fill=orange!10, font=\footnotesize},
    message/.style={->, >=stealth, thick, font=\tiny},
    return/.style={->, >=stealth, dashed, font=\tiny}
]

% Actores
\node[actor] (user) {Usuario};
\node[actor, right=of user] (editor) {Editor Visual};
\node[actor, right=of editor] (props) {Panel Props};
\node[actor, right=of props] (preview) {Vista Previa};
\node[actor, right=of preview] (monaco) {Monaco Editor};
\node[actor, right=of monaco] (valkey) {Valkey};

% Líneas de vida
\draw[dashed] (user.south) -- ++(0,-9);
\draw[dashed] (editor.south) -- ++(0,-9);
\draw[dashed] (props.south) -- ++(0,-9);
\draw[dashed] (preview.south) -- ++(0,-9);
\draw[dashed] (monaco.south) -- ++(0,-9);
\draw[dashed] (valkey.south) -- ++(0,-9);

% Mensajes
\draw[message] ([yshift=-1cm]user.south) -- ([yshift=-1cm]editor.south) node[midway, above, font=\tiny] {1. Clic en componente};
\draw[message] ([yshift=-1.8cm]editor.south) -- ([yshift=-1.8cm]props.south) node[midway, above, font=\tiny] {2. Cargar propiedades};
\draw[message] ([yshift=-2.6cm]user.south) -- ([yshift=-2.6cm]props.south) node[midway, above, font=\tiny] {3. Modificar propiedad};
\draw[message] ([yshift=-3.4cm]props.south) -- ([yshift=-3.4cm]preview.south) node[midway, above, font=\tiny] {4. Actualizar preview};
\draw[return] ([yshift=-4cm]preview.south) -- ([yshift=-4cm]props.south) node[midway, below, font=\tiny] {Renderizado};
\draw[message] ([yshift=-4.8cm]props.south) -- ([yshift=-4.8cm]editor.south) node[midway, above, font=\tiny] {5. Actualizar JSON (500ms)};
\draw[message] ([yshift=-5.6cm]editor.south) -- ([yshift=-5.6cm]monaco.south) node[midway, above, font=\tiny] {6. Sincronizar código};
\draw[message] ([yshift=-6.4cm]editor.south) -- ([yshift=-6.4cm]valkey.south) node[midway, above, font=\tiny] {7. Guardar estado};
\draw[return] ([yshift=-7cm]valkey.south) -- ([yshift=-7cm]editor.south) node[midway, below, font=\tiny] {Confirmación};
\draw[message] ([yshift=-7.8cm]editor.south) -- ([yshift=-7.8cm]user.south) node[midway, above, font=\tiny] {8. Notificar guardado};

\end{tikzpicture}
\caption{Diagrama de secuencia: Edición Visual de Componentes}
\label{fig:seq_edicion_visual}
\end{figure}

\vspace{0.5cm}

\textbf{Caso de Uso 4: Asistencia Contextual con Chat de IA}

\textbf{Actor:} Desarrollador

\textbf{Descripción:} El usuario interactúa con el asistente de IA para obtener ayuda, sugerencias o realizar modificaciones complejas mediante lenguaje natural.

\textbf{Flujo Principal:}

\begin{enumerate}
    \item El usuario selecciona un componente o sección de la aplicación
    \item Abre la pestaña ``Chat'' en el panel derecho
    \item Escribe una pregunta o solicitud en lenguaje natural (ejemplo: ``¿Cómo puedo validar que este campo sea un email válido?'')
    \item El sistema captura el contexto actual:
    \begin{itemize}
        \item Componente seleccionado y sus propiedades
        \item Estructura completa del formulario
        \item Historial de conversación de la sesión
    \end{itemize}
    \item El sistema envía el mensaje junto con el contexto a AWS Bedrock
    \item La IA analiza la solicitud y genera una respuesta contextualizada
    \item El sistema muestra la respuesta en el chat con formato Markdown
    \item Si la respuesta incluye código o cambios sugeridos, se presenta un botón ``Aplicar cambios''
    \item El usuario puede:
    \begin{itemize}
        \item Aceptar los cambios sugeridos (se aplican automáticamente)
        \item Rechazar los cambios (se mantiene el estado actual)
        \item Hacer preguntas de seguimiento
    \end{itemize}
    \item Si el usuario acepta los cambios, el sistema valida y actualiza el componente
    \item Se muestra una notificación de éxito
    \item El historial de conversación se mantiene durante toda la sesión
\end{enumerate}

\textbf{Postcondiciones:}
\begin{itemize}
    \item El usuario ha recibido asistencia contextual
    \item Los cambios sugeridos (si fueron aceptados) están aplicados
    \item El historial de conversación está disponible para referencia futura
\end{itemize}

La Figura \ref{fig:ui_chat_ia} muestra la interfaz del chat con el asistente de IA en acción, mientras que la Figura \ref{fig:seq_chat_ia} presenta el diagrama de secuencia de la interacción completa.

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    node distance=0.5cm and 1.2cm,
    actor/.style={rectangle, draw, minimum width=1.8cm, minimum height=0.6cm, fill=purple!10, font=\footnotesize},
    message/.style={->, >=stealth, thick, font=\tiny},
    return/.style={->, >=stealth, dashed, font=\tiny}
]

% Actores
\node[actor] (user) {Usuario};
\node[actor, right=of user] (editor) {Editor Visual};
\node[actor, right=of editor] (chat) {Chat UI};
\node[actor, right=of chat] (backend) {Backend};
\node[actor, right=of backend] (bedrock) {AWS Bedrock};
\node[actor, right=of bedrock] (session) {Session Store};

% Líneas de vida
\draw[dashed] (user.south) -- ++(0,-11);
\draw[dashed] (editor.south) -- ++(0,-11);
\draw[dashed] (chat.south) -- ++(0,-11);
\draw[dashed] (backend.south) -- ++(0,-11);
\draw[dashed] (bedrock.south) -- ++(0,-11);
\draw[dashed] (session.south) -- ++(0,-11);

% Mensajes
\draw[message] ([yshift=-1cm]user.south) -- ([yshift=-1cm]editor.south) node[midway, above, font=\tiny] {1. Seleccionar componente};
\draw[message] ([yshift=-1.8cm]user.south) -- ([yshift=-1.8cm]chat.south) node[midway, above, font=\tiny] {2. Abrir Chat};
\draw[message] ([yshift=-2.6cm]user.south) -- ([yshift=-2.6cm]chat.south) node[midway, above, font=\tiny] {3. Escribir pregunta};
\draw[message] ([yshift=-3.4cm]chat.south) -- ([yshift=-3.4cm]editor.south) node[midway, above, font=\tiny] {4. Capturar contexto};
\draw[return] ([yshift=-4cm]editor.south) -- ([yshift=-4cm]chat.south) node[midway, below, font=\tiny] {Contexto actual};
\draw[message] ([yshift=-4.8cm]chat.south) -- ([yshift=-4.8cm]session.south) node[midway, above, font=\tiny] {5. Obtener historial};
\draw[return] ([yshift=-5.4cm]session.south) -- ([yshift=-5.4cm]chat.south) node[midway, below, font=\tiny] {Conversaciones};
\draw[message] ([yshift=-6.2cm]chat.south) -- ([yshift=-6.2cm]backend.south) node[midway, above, font=\tiny] {6. Enviar mensaje};
\draw[message] ([yshift=-7cm]backend.south) -- ([yshift=-7cm]bedrock.south) node[midway, above, font=\tiny] {7. Consultar IA};
\draw[return] ([yshift=-7.6cm]bedrock.south) -- ([yshift=-7.6cm]backend.south) node[midway, below, font=\tiny] {Respuesta};
\draw[return] ([yshift=-8.4cm]backend.south) -- ([yshift=-8.4cm]chat.south) node[midway, below, font=\tiny] {Sugerencias};
\draw[message] ([yshift=-9.2cm]chat.south) -- ([yshift=-9.2cm]session.south) node[midway, above, font=\tiny] {8. Guardar historial};
\draw[message] ([yshift=-10cm]chat.south) -- ([yshift=-10cm]editor.south) node[midway, above, font=\tiny] {9. Aplicar cambios};
\draw[message] ([yshift=-10.8cm]chat.south) -- ([yshift=-10.8cm]user.south) node[midway, above, font=\tiny] {10. Notificar éxito};

\end{tikzpicture}
\caption{Diagrama de secuencia: Asistencia Contextual con Chat de IA}
\label{fig:seq_chat_ia}
\end{figure}

\vspace{0.5cm}

Estos casos de uso demuestran cómo Irakani Builder integra capacidades de IA de manera fluida en el flujo de trabajo del desarrollador, reduciendo significativamente el tiempo de desarrollo mientras mantiene el control total sobre el resultado final.



\subsection{Implementación de la Solución}

Esta sección documenta los aspectos técnicos de la implementación de Irakani Builder, incluyendo la configuración del entorno de desarrollo, el pipeline CI/CD, el desarrollo del backend y frontend, y la integración con servicios de AWS.

\subsubsection{Configuración del Entorno y CI/CD}

\paragraph{Arquitectura de CI/CD}
El proyecto Irakani Builder implementa un pipeline completo de CI/CD utilizando AWS CodePipeline integrado con Bitbucket como repositorio de código fuente. La arquitectura está diseñada para automatizar el proceso de construcción, pruebas y despliegue de la aplicación.

\subparagraph{Componentes del Pipeline}

\textbf{1. Repositorio de Código (Bitbucket)}

\begin{itemize}
    \item \textbf{Repositorio}: \texttt{expertfect/irakani-app-builder}
    \item \textbf{Rama principal}: \texttt{main}
    \item \textbf{Conexión AWS}: Configurada mediante AWS CodeStar Connections
    \item \textbf{ARN de conexión}: \texttt{[ARN_CENSURADO]}
\end{itemize}

\textbf{2. Infraestructura como Código (AWS CDK)}

El proyecto utiliza AWS CDK (Cloud Development Kit) para definir y desplegar toda la infraestructura de manera programática. La estructura del pipeline se encuentra en el directorio \texttt{ci-cd/}:

\begin{verbatim}
ci-cd/
├── lib/                    # Definiciones de stacks CDK
├── bin/                    # Punto de entrada de la aplicación CDK
├── scripts/                # Scripts de automatización
├── deploy-buildspec.yml    # Especificación de construcción
└── docker-compose.yml      # Orquestación de contenedores
\end{verbatim}

\textbf{3. Etapas del Pipeline}

El pipeline se compone de seis etapas principales:

\textbf{Stage 1: Source (Obtención de Código)}
\begin{itemize}
    \item Se activa automáticamente con cada push a la rama \texttt{main}
    \item Obtiene el código fuente desde Bitbucket
    \item Genera un artefacto con el código fuente para las siguientes etapas
\end{itemize}

\textbf{Stage 2: Build (Construcción)}

Ejecuta dos procesos de construcción en paralelo:

\textit{Frontend Build:}
\begin{lstlisting}[language=yaml, caption=Buildspec para frontend]
version: 0.2
phases:
  pre_build:
    commands:
      - echo Logging in to Amazon ECR...
      - aws ecr get-login-password --region [REGIÓN_AWS] | 
        docker login --username AWS --password-stdin 
        [ECR_ENDPOINT_CENSURADO]
  build:
    commands:
      - echo Building Docker image for frontend...
      - docker build -t irakani-builder-frontend-ci-cd:latest 
        -f Dockerfile.frontend .
      - docker tag irakani-builder-frontend-ci-cd:latest 
        [ECR_ENDPOINT_CENSURADO]/
        irakani-builder-frontend-ci-cd:latest
  post_build:
    commands:
      - echo Pushing Docker image to ECR...
      - docker push [ECR_ENDPOINT_CENSURADO]/
        irakani-builder-frontend-ci-cd:latest
\end{lstlisting}

\textit{Backend Build:} Similar al frontend, pero utilizando el Dockerfile del backend.

\textbf{Stage 3: Deploy (Despliegue)}

Utiliza AWS Systems Manager (SSM) para ejecutar comandos en la instancia EC2. El proceso genera dinámicamente un archivo \texttt{docker-compose.yml}, lo sube a S3 y envía comandos a la instancia EC2 para descargar las nuevas imágenes desde ECR e iniciar los contenedores.

\textbf{Stage 4: Manual Approval (Aprobación Manual)}

Este stage requiere aprobación humana antes de proceder a producción:

\begin{itemize}
    \item Permite verificar el despliegue en la instancia EC2 antes de crear AMI
    \item Evita crear AMIs con código defectuoso
    \item Proporciona un punto de control para revisión humana
    \item Pipeline se pausa automáticamente
    \item Se envía notificación SNS al equipo
    \item Revisor verifica la aplicación y aprueba o rechaza desde la consola de CodePipeline
\end{itemize}

\textbf{Stage 5: Create AMI (Creación de AMI)}

Este stage crea una Amazon Machine Image (AMI) de la instancia EC2 con la aplicación desplegada:

\begin{itemize}
    \item Espera a que el deployment termine completamente
    \item Crea AMI con timestamp sin reiniciar la instancia
    \item Espera a que la AMI esté disponible
    \item Crea nueva versión del Launch Template con la nueva AMI
    \item Establece la nueva versión como default
\end{itemize}

Beneficios de la AMI:
\begin{itemize}
    \item \textbf{Despliegues rápidos}: Nuevas instancias se lanzan en $\sim$2 minutos
    \item \textbf{Consistencia}: Todas las instancias tienen exactamente la misma configuración
    \item \textbf{Rollback rápido}: Posibilidad de volver a una AMI anterior en minutos
    \item \textbf{Escalabilidad}: Auto Scaling puede lanzar instancias automáticamente
\end{itemize}

\textbf{Stage 6: Update ASG (Actualización de Auto Scaling Group)}

Este stage final actualiza el Auto Scaling Group con la nueva AMI mediante un rolling update:

Características del Rolling Update:
\begin{itemize}
    \item \textbf{MinHealthyPercentage: 50\%}: Mantiene al menos 50\% de instancias saludables durante el update
    \item \textbf{InstanceWarmup: 300s}: Espera 5 minutos para que cada instancia nueva esté lista
    \item \textbf{Zero Downtime}: Los usuarios no experimentan interrupciones
    \item \textbf{Rollback automático}: Si las nuevas instancias fallan health checks, se revierte
\end{itemize}

Proceso del Rolling Update:
\begin{enumerate}
    \item ASG lanza una nueva instancia con la nueva AMI
    \item Espera 5 minutos (warmup) para que la instancia esté lista
    \item Verifica health checks (HTTP en puerto [PUERTO_CENSURADO])
    \item Si está saludable, termina una instancia antigua
    \item Repite hasta que todas las instancias estén actualizadas
    \item Limpia AMIs antiguas para ahorrar costos
\end{enumerate}

\subparagraph{Script de Despliegue en EC2}

El archivo \texttt{deploy.sh} en la instancia EC2 maneja el proceso de actualización:

\begin{lstlisting}[language=bash, caption=Script de despliegue]
#!/bin/bash
set -e  # Salir si hay error

echo "Iniciando despliegue de Irakani Builder..."

# Autenticar con ECR
echo "Autenticando con ECR..."
aws ecr get-login-password --region [REGIÓN_AWS] | 
  docker login --username AWS --password-stdin 
  [ECR_ENDPOINT_CENSURADO]

# Detener contenedores actuales
echo "Deteniendo contenedores actuales..."
docker-compose down || true

# Limpiar imágenes antiguas
echo "Limpiando imágenes antiguas..."
docker image prune -af

# Descargar nuevas imágenes
echo "Descargando nuevas imágenes..."
docker-compose pull

# Iniciar contenedores
echo "Iniciando contenedores..."
docker-compose up -d

# Verificar estado
echo "Verificando estado de contenedores..."
docker-compose ps

# Health check
echo "Verificando salud de la aplicación..."
sleep 10

if curl -f [URL_BACKEND_LOCAL]/api/check > /dev/null 2>&1; then
  echo "Backend está funcionando"
else
  echo "Backend no responde"
  exit 1
fi

if curl -f [URL_FRONTEND_LOCAL] > /dev/null 2>&1; then
  echo "Frontend está funcionando"
else
  echo "Frontend no responde"
  exit 1
fi

echo "Despliegue completado exitosamente!"
\end{lstlisting}

\subparagraph{Infraestructura de Red}

\textbf{VPC Existente:}
\begin{itemize}
    \item \textbf{VPC ID}: \texttt{[VPC_ID_CENSURADO]}
    \item \textbf{Subnet Pública}: \texttt{[SUBNET_ID_CENSURADA]}
    \item \textbf{Security Groups}: Configurados para permitir tráfico HTTP/HTTPS y SSH
\end{itemize}

\textbf{Instancia EC2:}
\begin{itemize}
    \item \textbf{Tipo}: t3.small
    \item \textbf{AMI}: Amazon Linux 2
    \item \textbf{Rol IAM}: Con permisos para ECR, S3, SSM
    \item \textbf{Software instalado}: Docker, Docker Compose, AWS CLI
\end{itemize}

\subparagraph{Monitoreo y Logs del Pipeline}

\textbf{1. Monitoreo en CodePipeline:}

\begin{lstlisting}[language=bash]
# Ver estado del pipeline
aws codepipeline get-pipeline-state 
  --name irakani-builder-ci-cd-pipeline

# Ver historial de ejecuciones
aws codepipeline list-pipeline-executions 
  --pipeline-name irakani-builder-ci-cd-pipeline --max-items 10
\end{lstlisting}

\textbf{2. Logs de CodeBuild:}

\begin{lstlisting}[language=bash]
# Listar builds recientes
aws codebuild list-builds-for-project 
  --project-name irakani-builder-frontend-build

# Ver logs de un build específico
aws logs get-log-events 
  --log-group-name /aws/codebuild/irakani-builder-frontend-build 
  --log-stream-name <log-stream-name>
\end{lstlisting}

\textbf{3. Logs de la Aplicación en EC2:}

\begin{lstlisting}[language=bash]
# Conectarse a EC2 via SSM
aws ssm start-session --target <instance-id>

# Ver logs de Docker Compose
cd /opt/irakani-builder
docker-compose logs -f

# Ver logs específicos de un servicio
docker-compose logs -f backend
docker-compose logs -f frontend
\end{lstlisting}

\subparagraph{Flujo Completo del Pipeline}

El flujo detallado del pipeline es el siguiente:

\begin{enumerate}
    \item \textbf{Developer Push (t=0s)}: El desarrollador hace push a la rama \texttt{main}
    \item \textbf{Bitbucket Webhook (t=1s)}: Bitbucket detecta el push y notifica a AWS
    \item \textbf{Stage 1: Source (t=2-5s)}: CodePipeline descarga el código y crea artefacto
    \item \textbf{Stage 2: Build (t=5s-5min)}: Construcción paralela de frontend y backend
    \item \textbf{Stage 3: Deploy (t=5min-7min)}: Despliegue en EC2 con health checks
    \item \textbf{Stage 4: Manual Approval}: Pausa para revisión humana
    \item \textbf{Stage 5: Create AMI (5-10min)}: Creación de AMI y actualización de Launch Template
    \item \textbf{Stage 6: Update ASG (5-15min)}: Rolling update del Auto Scaling Group
\end{enumerate}

\textbf{Tiempo Total del Pipeline:}
\begin{itemize}
    \item Sin AMI/ASG: 6-8 minutos desde push hasta aplicación desplegada
    \item Con AMI/ASG: 15-25 minutos (incluye aprobación manual y rolling update)
\end{itemize}

\subparagraph{Configuración de Notificaciones}

El sistema implementa notificaciones mediante SNS y CloudWatch Alarms:

\textbf{SNS para Alertas del Pipeline:}
\begin{lstlisting}[language=bash]
# Crear tópico SNS
aws sns create-topic --name irakani-builder-pipeline-notifications

# Suscribir email
aws sns subscribe 
  --topic-arn [ARN_SNS_CENSURADO]:
    irakani-builder-pipeline-notifications 
  --protocol email 
  --notification-endpoint developer@irakani.com
\end{lstlisting}

\textbf{CloudWatch Alarms:}
\begin{lstlisting}[language=bash]
# Alarma para builds fallidos
aws cloudwatch put-metric-alarm 
  --alarm-name irakani-builder-build-failures 
  --alarm-description "Alerta cuando fallan builds" 
  --metric-name FailedBuilds 
  --namespace AWS/CodeBuild 
  --statistic Sum 
  --period 300 
  --threshold 1 
  --comparison-operator GreaterThanThreshold

# Alarma para alta utilización de CPU en EC2
aws cloudwatch put-metric-alarm 
  --alarm-name irakani-builder-high-cpu 
  --alarm-description "Alerta cuando CPU > 80%" 
  --metric-name CPUUtilization 
  --namespace AWS/EC2 
  --statistic Average 
  --period 300 
  --threshold 80 
  --comparison-operator GreaterThanThreshold
\end{lstlisting}

\textbf{Arquitectura del Pipeline CI/CD}

El proyecto implementa un pipeline completo de CI/CD utilizando AWS CodePipeline integrado con Bitbucket como repositorio de código fuente. El pipeline consta de 6 etapas principales:

\begin{enumerate}
    \item \textbf{Stage 1 - Source:} Obtención automática del código desde Bitbucket al detectar cambios en la rama \texttt{main}
    \item \textbf{Stage 2 - Build:} Construcción paralela de imágenes Docker para frontend (React) y backend (Node.js), con push a Amazon ECR
    \item \textbf{Stage 3 - Deploy:} Despliegue automático en instancia EC2 mediante AWS Systems Manager (SSM)
    \item \textbf{Stage 4 - Manual Approval:} Punto de control para revisión humana antes de proceder a producción
    \item \textbf{Stage 5 - Create AMI:} Creación de Amazon Machine Image para escalabilidad
    \item \textbf{Stage 6 - Update ASG:} Actualización del Auto Scaling Group mediante rolling update
\end{enumerate}

\textbf{Componentes de Infraestructura:}

\begin{itemize}
    \item \textbf{Repositorio:} Bitbucket (\texttt{expertfect/irakani-app-builder})
    \item \textbf{Infraestructura como Código:} AWS CDK (Cloud Development Kit)
    \item \textbf{Contenedores:} Docker con orquestación mediante Docker Compose
    \item \textbf{Registro de Imágenes:} Amazon ECR (Elastic Container Registry)
    \item \textbf{Cómputo:} Instancias EC2 t3.small con Amazon Linux 2
    \item \textbf{Escalabilidad:} Auto Scaling Group con Launch Templates
    \item \textbf{Monitoreo:} CloudWatch Logs, Metrics y Alarms
\end{itemize}

El tiempo total del pipeline es de 6-8 minutos para despliegue básico, o 15-25 minutos cuando incluye la creación de AMI y actualización del Auto Scaling Group.

\subsubsection{Desarrollo del Backend (BFF)}

\paragraph{Arquitectura del Backend}
El backend de Irakani Builder está diseñado como un BFF (Backend for Frontend) que actúa como capa de orquestación entre el frontend y los servicios externos (AWS Bedrock, bases de datos, S3, etc.).

\subparagraph{Stack Tecnológico}

\begin{lstlisting}[ caption=Dependencias principales del backend]
// package.json - Dependencias principales
{
  "dependencies": {
    "@aws-sdk/client-bedrock-runtime": "^3.0.0",  // IA Generativa
    "@aws-sdk/client-dynamodb": "^3.840.0",       // Base de datos NoSQL
    "@aws-sdk/client-s3": "^3.0.0",               // Almacenamiento
    "express": "^4.18.2",                          // Framework web
    "redis": "^4.6.0",                             // Cliente Valkey/Redis
    "axios": "^1.4.0",                             // Cliente HTTP
    "jsonwebtoken": "^9.0.2",                      // Autenticacion JWT
    "helmet": "^8.1.0",                            // Seguridad HTTP
    "cors": "^2.8.5"                               // CORS
  }
}
\end{lstlisting}

\paragraph{Implementación del Cliente API Irakani}
El backend centraliza todas las peticiones hacia el sistema legado de Irakani mediante wrappers de Axios configurados específicamente:

\begin{lstlisting}[ caption=Cliente API Irakani]
// backend/server.js - Cliente API Irakani
const axios = require('axios');

// Configuracion base para API de Irakani
const IRAKANI_API_BASE = 
  '[ENDPOINT_API_CENSURADO]';

// Endpoint para analisis de aplicaciones
app.post('/api/analyze', async (req, res) => {
  try {
    const response = await axios.post(
      `${IRAKANI_API_BASE}/analyze`,
      req.body,
      {
        headers: { 'Content-Type': 'application/json' },
        timeout: 30000  // 30 segundos de timeout
      }
    );
    res.json(response.data);
  } catch (error) {
    console.error('Error en analisis:', error);
    res.status(500).json({ 
      error: 'Error en analisis', 
      message: error.message,
      details: error.response?.data || {}
    });
  }
});

// Endpoint para generacion de aplicaciones
app.post('/api/generate', async (req, res) => {
  try {
    const response = await axios.post(
      `${IRAKANI_API_BASE}/generate`,
      req.body,
      {
        headers: { 'Content-Type': 'application/json' },
        timeout: 60000  // 60 segundos para generacion
      }
    );
    res.json(response.data);
  } catch (error) {
    console.error('Error en generacion:', error);
    res.status(500).json({ 
      error: 'Error en generacion', 
      message: error.message,
      details: error.response?.data || {}
    });
  }
});
\end{lstlisting}

\textbf{Características del Cliente:}
\begin{itemize}
    \item \textbf{Timeouts configurables}: Diferentes tiempos según la operación
    \item \textbf{Manejo de errores robusto}: Captura y transforma errores de la API
    \item \textbf{Logging detallado}: Registra todas las peticiones para debugging
    \item \textbf{Retry logic}: Implementado en el cliente Axios para reintentos automáticos
\end{itemize}

\paragraph{Implementación de Valkey (Redis)}
Valkey es un fork de Redis que se utiliza para el almacenamiento de sesiones y caché de datos. La implementación proporciona una capa de persistencia rápida y eficiente.

\subparagraph{Configuración del Cliente Valkey}

\begin{lstlisting}[ caption=Configuración del cliente Valkey]
// backend/routes/valkey.js
const { createClient } = require('redis');

// Configuracion de conexion
const VALKEY_CONFIG = {
  socket: {
    host: process.env.VALKEY_HOST || 
      '[VALKEY_ENDPOINT_CENSURADO]',
    port: parseInt(process.env.VALKEY_PORT) || [PUERTO_CENSURADO]
  },
  retry_strategy: (options) => {
    if (options.error && options.error.code === 'ECONNREFUSED') {
      return new Error('El servidor Valkey rechazo la conexion');
    }
    if (options.total_retry_time > 1000 * 60 * 60) {
      return new Error('Tiempo de reintento agotado');
    }
    if (options.attempt > 10) {
      return undefined;
    }
    // Backoff exponencial: 100ms, 200ms, 400ms, ...
    return Math.min(options.attempt * 100, 3000);
  }
};

// Inicializacion del cliente
let valkeyClient = null;

const initValkeyClient = async () => {
  if (!valkeyClient) {
    try {
      valkeyClient = createClient(VALKEY_CONFIG);
      
      valkeyClient.on('error', (err) => {
        console.error('Error de cliente Valkey:', err);
      });
      
      valkeyClient.on('connect', () => {
        console.log('Conectado a Valkey');
      });
      
      valkeyClient.on('reconnecting', () => {
        console.log('Reconectando a Valkey...');
      });
      
      await valkeyClient.connect();
    } catch (error) {
      console.error('Error conectando a Valkey:', error);
      valkeyClient = null;
    }
  }
  return valkeyClient;
};
\end{lstlisting}

\subparagraph{Operaciones de Sesión con Valkey}

\textbf{1. SET - Establecer valor con TTL:}

\begin{lstlisting}[ caption=Operación SET con TTL]
// Middleware para verificar conexion
const ensureConnection = async (req, res, next) => {
  try {
    const client = await initValkeyClient();
    if (!client) {
      return res.status(503).json({ 
        error: 'Servicio Valkey no disponible' 
      });
    }
    req.valkeyClient = client;
    next();
  } catch (error) {
    res.status(503).json({ 
      error: 'Error conectando a Valkey', 
      message: error.message 
    });
  }
};

// Endpoint SET con TTL opcional
router.post('/set', ensureConnection, async (req, res) => {
  try {
    const { key, value, ttl } = req.body;
    
    if (!key || value === undefined) {
      return res.status(400).json({ 
        error: 'key y value son requeridos' 
      });
    }
    
    // Si se proporciona TTL, usar setEx (SET con expiracion)
    if (ttl) {
      await req.valkeyClient.setEx(key, ttl, value);
      console.log(`SET ${key} con TTL de ${ttl}s`);
    } else {
      await req.valkeyClient.set(key, value);
      console.log(`SET ${key} sin expiracion`);
    }
    
    res.json({ success: true });
  } catch (error) {
    console.error('Error en SET:', error);
    res.status(500).json({ 
      error: 'Error estableciendo valor', 
      message: error.message 
    });
  }
});
\end{lstlisting}

\textbf{2. GET - Obtener valor:}

\begin{lstlisting}[ caption=Operación GET]
// Soporta tanto GET como POST para flexibilidad
router.get('/get/:key?', ensureConnection, async (req, res) => {
  try {
    const key = req.params.key || req.query.key;
    
    if (!key) {
      return res.status(400).json({ 
        error: 'key es requerido como parametro o query' 
      });
    }
    
    const value = await req.valkeyClient.get(key);
    console.log(`GET ${key}: ${value ? 'encontrado' : 'no encontrado'}`);
    
    res.json({ value });
  } catch (error) {
    console.error('Error en GET:', error);
    res.status(500).json({ 
      error: 'Error obteniendo valor', 
      message: error.message 
    });
  }
});
\end{lstlisting}

\textbf{3. DEL - Eliminar valor:}

\begin{lstlisting}[ caption=Operación DELETE]
router.post('/del', ensureConnection, async (req, res) => {
  try {
    const { key } = req.body;
    
    if (!key) {
      return res.status(400).json({ error: 'key es requerido' });
    }
    
    await req.valkeyClient.del(key);
    console.log(`DEL ${key}`);
    
    res.json({ success: true });
  } catch (error) {
    console.error('Error en DEL:', error);
    res.status(500).json({ 
      error: 'Error eliminando valor', 
      message: error.message 
    });
  }
});
\end{lstlisting}

\textbf{4. EXISTS - Verificar existencia:}

\begin{lstlisting}[ caption=Operación EXISTS]
router.post('/exists', ensureConnection, async (req, res) => {
  try {
    const { key } = req.body;
    
    if (!key) {
      return res.status(400).json({ error: 'key es requerido' });
    }
    
    const exists = await req.valkeyClient.exists(key);
    console.log(`EXISTS ${key}: ${exists === 1}`);
    
    res.json({ exists: exists === 1 });
  } catch (error) {
    console.error('Error en EXISTS:', error);
    res.status(500).json({ 
      error: 'Error verificando existencia', 
      message: error.message 
    });
  }
});
\end{lstlisting}

\subparagraph{Casos de Uso de Valkey en Irakani Builder}

\textbf{1. Gestión de Sesiones de Usuario:}

\begin{lstlisting}
// Almacenar sesion de usuario con TTL de 24 horas
const sessionKey = `session:${userId}`;
const sessionData = JSON.stringify({
  userId,
  email: user.email,
  role: user.role,
  loginTime: Date.now()
});
await valkeyClient.setEx(sessionKey, 86400, sessionData);  // 24 horas
\end{lstlisting}

\textbf{2. Caché de Conexiones de Base de Datos:}

\begin{lstlisting}
// Almacenar token de conexion a BD con TTL de 1 hora
const connectionKey = `db:connection:${connectionId}`;
const connectionData = JSON.stringify({
  connectionId,
  dbType: 'mysql',
  host: 'db.example.com',
  token: encryptedToken
});
await valkeyClient.setEx(connectionKey, 3600, connectionData);  // 1 hora
\end{lstlisting}

\textbf{3. Rate Limiting:}

\begin{lstlisting}
// Limitar peticiones por usuario
const rateLimitKey = `ratelimit:${userId}:${endpoint}`;
const count = await valkeyClient.incr(rateLimitKey);

if (count === 1) {
  // Primera peticion, establecer TTL de 1 minuto
  await valkeyClient.expire(rateLimitKey, 60);
}

if (count > 100) {
  return res.status(429).json({ error: 'Demasiadas peticiones' });
}
\end{lstlisting}

\paragraph{Middleware de Autenticación}
El sistema implementa un middleware de autenticación robusto que valida el acceso usando tokens JWT y mantiene las sesiones activas en Valkey.

\subparagraph{Implementación del Middleware de Autenticación}

\begin{lstlisting}[ caption=Middleware de autenticación]
// backend/middleware/auth.js
const SecurityService = require('../services/SecurityService');
const DatabaseService = require('../services/DatabaseService');

/**
 * Middleware de autenticacion para conexiones de base de datos
 * Valida el token JWT y verifica la conexion activa
 */
const authenticateDB = (req, res, next) => {
  // Extraer token del header Authorization
  const token = req.headers.authorization?.replace('Bearer ', '');
  const connectionId = req.headers['x-connection-id'];
  
  // Validar presencia de credenciales
  if (!token || !connectionId) {
    return res.status(401).json({ 
      error: 'Token y connectionId requeridos',
      details: 'Debe proporcionar un token de autenticacion y un ID de conexion validos'
    });
  }
  
  try {
    // Verificar validez del token JWT
    SecurityService.verifyToken(token);
    
    // Validar que el token corresponda a la conexion
    if (!DatabaseService.validateToken(connectionId, token)) {
      return res.status(401).json({ 
        error: 'Token invalido para esta conexion',
        details: 'El token proporcionado no corresponde a la conexion especificada'
      });
    }
    
    // Adjuntar connectionId al request para uso posterior
    req.connectionId = connectionId;
    next();
  } catch (error) {
    console.error('Error en autenticacion:', error);
    res.status(401).json({ 
      error: 'Token invalido',
      details: error.message
    });
  }
};

module.exports = { authenticateDB };
\end{lstlisting}

\subparagraph{Servicio de Seguridad}

\begin{lstlisting}[ caption=Servicio de seguridad]
// backend/services/SecurityService.js
const jwt = require('jsonwebtoken');
const crypto = require('crypto');

class SecurityService {
  constructor() {
    this.jwtSecret = process.env.JWT_SECRET || 
      'PYelaMo_GeE1Ki62783ukS_&b14T';
    this.encryptionKey = process.env.DB_SECRET_KEY || 
      'default_secret_key_2024';
  }
  
  /**
   * Genera un token JWT para una conexion de base de datos
   * @param {string} connectionId - ID unico de la conexion
   * @param {string} userId - ID del usuario
   * @param {object} metadata - Metadatos adicionales
   * @returns {string} Token JWT firmado
   */
  generateToken(connectionId, userId, metadata = {}) {
    const payload = {
      connectionId,
      userId,
      ...metadata,
      iat: Math.floor(Date.now() / 1000),
      exp: Math.floor(Date.now() / 1000) + (60 * 60 * 24)  // 24 horas
    };
    return jwt.sign(payload, this.jwtSecret);
  }
  
  /**
   * Verifica la validez de un token JWT
   * @param {string} token - Token a verificar
   * @returns {object} Payload decodificado
   * @throws {Error} Si el token es invalido o ha expirado
   */
  verifyToken(token) {
    try {
      return jwt.verify(token, this.jwtSecret);
    } catch (error) {
      if (error.name === 'TokenExpiredError') {
        throw new Error('Token expirado');
      }
      throw new Error('Token invalido');
    }
  }
  
  /**
   * Encripta credenciales de base de datos
   * @param {object} credentials - Credenciales a encriptar
   * @returns {string} Credenciales encriptadas en base64
   */
  encryptCredentials(credentials) {
    const algorithm = 'aes-256-cbc';
    const key = crypto.scryptSync(this.encryptionKey, 'salt', 32);
    const iv = crypto.randomBytes(16);
    
    const cipher = crypto.createCipheriv(algorithm, key, iv);
    let encrypted = cipher.update(
      JSON.stringify(credentials), 'utf8', 'hex'
    );
    encrypted += cipher.final('hex');
    
    return Buffer.from(
      iv.toString('hex') + ':' + encrypted
    ).toString('base64');
  }
  
  /**
   * Desencripta credenciales de base de datos
   * @param {string} encryptedData - Datos encriptados en base64
   * @returns {object} Credenciales desencriptadas
   */
  decryptCredentials(encryptedData) {
    const algorithm = 'aes-256-cbc';
    const key = crypto.scryptSync(this.encryptionKey, 'salt', 32);
    
    const data = Buffer.from(encryptedData, 'base64').toString('utf8');
    const [ivHex, encrypted] = data.split(':');
    const iv = Buffer.from(ivHex, 'hex');
    
    const decipher = crypto.createDecipheriv(algorithm, key, iv);
    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return JSON.parse(decrypted);
  }
}

module.exports = new SecurityService();
\end{lstlisting}

\subparagraph{Flujo de Autenticación}

\textbf{1. Creación de Conexión:}

\begin{lstlisting}
// Cliente solicita conexion a base de datos
POST /api/database/connect
{
  "dbType": "mysql",
  "config": {
    "host": "db.example.com",
    "port": [PUERTO_CENSURADO],
    "user": "admin",
    "password": "encrypted_password",
    "database": "mydb"
  }
}

// Servidor responde con token y connectionId
{
  "connectionId": "conn_abc123xyz",
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "status": "connected"
}
\end{lstlisting}

\textbf{2. Uso del Token en Peticiones Subsecuentes:}

\begin{lstlisting}
// Cliente incluye token en headers
POST /api/database/query

Headers:
  Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
  x-connection-id: conn_abc123xyz

Body:
{
  "query": "SELECT * FROM users WHERE active = ?",
  "params": [true]
}
\end{lstlisting}

\textbf{3. Validación en Middleware:}

El middleware \texttt{authenticateDB} valida:
\begin{enumerate}
    \item Presencia de token y connectionId
    \item Validez del token JWT (firma y expiración)
    \item Correspondencia entre token y connectionId
    \item Existencia de la conexión activa
\end{enumerate}

Si todo es válido, la petición continúa. Si falla alguna validación, retorna 401 Unauthorized.

\subparagraph{Integración con Valkey para Sesiones}

\begin{lstlisting}[ caption=Gestión de sesiones con Valkey]
// Almacenar sesion en Valkey al crear conexion
const sessionKey = `session:${connectionId}`;
const sessionData = {
  userId,
  connectionId,
  dbType: config.dbType,
  createdAt: Date.now(),
  lastActivity: Date.now()
};

await valkeyClient.setEx(
  sessionKey, 
  86400,  // 24 horas
  JSON.stringify(sessionData)
);

// Actualizar ultima actividad en cada peticion
const updateActivity = async (connectionId) => {
  const sessionKey = `session:${connectionId}`;
  const session = await valkeyClient.get(sessionKey);
  
  if (session) {
    const data = JSON.parse(session);
    data.lastActivity = Date.now();
    await valkeyClient.setEx(sessionKey, 86400, JSON.stringify(data));
  }
};

// Limpiar sesion al cerrar conexion
const closeSession = async (connectionId) => {
  const sessionKey = `session:${connectionId}`;
  await valkeyClient.del(sessionKey);
  console.log(`Sesion cerrada: ${connectionId}`);
};
\end{lstlisting}

El backend de Irakani Builder está diseñado como un Backend for Frontend (BFF) que actúa como capa de orquestación entre el frontend React y los servicios externos de AWS.

\textbf{Stack Tecnológico del Backend:}

\begin{itemize}
    \item \textbf{Framework:} Node.js con Express.js
    \item \textbf{SDK AWS:} @aws-sdk/client-bedrock-runtime, @aws-sdk/client-s3, @aws-sdk/client-dynamodb
    \item \textbf{Caché:} Redis (cliente para Valkey)
    \item \textbf{Autenticación:} jsonwebtoken para JWT
    \item \textbf{Seguridad:} helmet para headers HTTP seguros
    \item \textbf{Cliente HTTP:} axios para peticiones a APIs externas
\end{itemize}

\textbf{Servicios Implementados:}

\begin{enumerate}
    \item \textbf{Cliente API Irakani:} Wrapper de Axios para comunicación con el sistema legado de Irakani, con manejo de timeouts configurables.
    
    \item \textbf{Servicio Valkey (Redis):} Implementación de caché distribuido para:
    \begin{itemize}
        \item Gestión de sesiones de usuario con TTL de 24 horas
        \item Caché de conexiones a bases de datos con TTL de 1 hora
        \item Rate limiting por usuario y endpoint
        \item Operaciones: SET, GET, DEL, EXISTS con soporte para expiración automática
    \end{itemize}
    
    \item \textbf{Middleware de Autenticación:} Sistema robusto de validación de tokens JWT que:
    \begin{itemize}
        \item Verifica la validez y firma de tokens JWT
        \item Valida la correspondencia entre token y connectionId
        \item Gestiona la expiración de tokens (24 horas)
        \item Encripta/desencripta credenciales de bases de datos usando AES-256-CBC
    \end{itemize}
\end{enumerate}

\subsubsection{Integración con AWS Bedrock}

AWS Bedrock es el servicio de IA Generativa que potencia las capacidades inteligentes de Irakani Builder. La integración permite la generación automática de código, aplicaciones, y asistencia en tiempo real.

\paragraph{Configuración del Cliente Bedrock}

La configuración del cliente AWS SDK v3 se realiza en el backend, permitiendo tanto desarrollo local con credenciales explícitas como producción usando roles IAM de EC2:

\begin{lstlisting}[ caption={Configuración del cliente AWS Bedrock}]
// backend/server.js - Configuracion AWS SDK v3
const { BedrockRuntimeClient, ConverseCommand, 
        ConverseStreamCommand, InvokeModelCommand } = 
  require('@aws-sdk/client-bedrock-runtime');

// Configuracion del cliente AWS
const awsConfig = {
  region: process.env.AWS_REGION || '[REGIÓN_AWS]'
};

// Solo agregar credenciales si estan definidas (desarrollo local)
// En produccion, usa el rol IAM de la instancia EC2
if (process.env.AWS_ACCESS_KEY_ID && 
    process.env.AWS_SECRET_ACCESS_KEY) {
  awsConfig.credentials = {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
    sessionToken: process.env.AWS_SESSION_TOKEN
  };
}

const bedrockClient = new BedrockRuntimeClient(awsConfig);
\end{lstlisting}

\paragraph{Modelos Utilizados y Estructura de Precios}

El sistema utiliza diferentes modelos de AWS Bedrock según la tarea, optimizando costos y rendimiento:

\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|}
\hline
\textbf{Modelo} & \textbf{Input (por 1K tokens)} & \textbf{Output (por 1K tokens)} \\
\hline
Claude Sonnet 4 & [PRECIO CENSURADO] & [PRECIO CENSURADO] \\
Claude 3.5 Haiku & [PRECIO CENSURADO] & [PRECIO CENSURADO] \\
Llama 4 Maverick 17B & [PRECIO CENSURADO] & [PRECIO CENSURADO] \\
\hline
\end{tabular}
\caption{Precios de modelos de texto en AWS Bedrock}
\end{table}

\begin{table}[h]
\centering
\begin{tabular}{|l|c|}
\hline
\textbf{Modelo} & \textbf{Precio por Imagen} \\
\hline
Titan Image Generator V2 & [PRECIO CENSURADO] \\
\hline
\end{tabular}
\caption{Precios de modelos de generación de imágenes}
\end{table}

La función de cálculo de costos permite trazabilidad financiera de cada operación:

\begin{lstlisting}[ caption={Función de cálculo de costos}]
function calculateCost(model, inputTokens = 0, 
                      outputTokens = 0, imageCount = 0) {
  const pricing = MODEL_PRICING[model];
  if (!pricing) return 0;
  
  // Para modelos de generacion de imagenes
  if (model.includes('titan-image')) {
    return imageCount * pricing.perImage;
  }
  
  // Para modelos de texto
  const inputCost = (inputTokens / 1000) * pricing.input;
  const outputCost = (outputTokens / 1000) * pricing.output;
  return inputCost + outputCost;
}
\end{lstlisting}

\paragraph{Servicio de Chat con Bedrock}

El sistema implementa dos modalidades de chat: respuesta completa y streaming en tiempo real.

\textbf{Chat Básico (Sin Streaming):} Utilizado para operaciones que requieren la respuesta completa antes de procesarla:

\begin{lstlisting}[ caption={Endpoint de chat básico con Bedrock}]
app.post('/api/chat/bedrock', async (req, res) => {
  try {
    const { messages, systemPrompt } = req.body;
    
    // Configurar comando para Bedrock
    const command = new ConverseCommand({
      modelId: 'us.anthropic.claude-sonnet-4-20250514-v1:0',
      messages,
      system: systemPrompt ? [{ text: systemPrompt }] : [],
      inferenceConfig: {
        maxTokens: 8000,
        temperature: 0.4,  // Creatividad moderada
        topP: 0.4,
        stopSequences: []
      }
    });
    
    const result = await bedrockClient.send(command);
    const output = result.output.message.content[0].text;
    
    // Trazabilidad de tokens y costo
    const usage = result.usage;
    const cost = calculateCost('claude-sonnet-4', 
                               usage.inputTokens, 
                               usage.outputTokens);
    
    console.log('Chat Bedrock:', {
      inputTokens: usage.inputTokens,
      outputTokens: usage.outputTokens,
      cost: `$${cost.toFixed(6)}`
    });
    
    // Guardar uso en DynamoDB
    await usageLogService.logUsage(
      req.headers['x-user-id'] || 'anonymous',
      usage.inputTokens,
      usage.outputTokens,
      'claude-sonnet-4',
      req.headers['x-schema'] || 'chat',
      req.headers['x-context'] || 'default'
    );
    
    res.json({ message: output });
  } catch (error) {
    console.error('Error en chat con Bedrock:', error);
    res.status(500).json({ error: 'Error en chat con Bedrock' });
  }
});
\end{lstlisting}

\textbf{Chat con Streaming:} Proporciona respuestas en tiempo real usando Server-Sent Events (SSE), mejorando la experiencia de usuario:

\begin{lstlisting}[ caption={Endpoint de chat con streaming}]
app.post('/api/chat/bedrock/stream', async (req, res) => {
  try {
    const { messages, systemPrompt } = req.body;
    
    // Configurar headers para Server-Sent Events
    res.writeHead(200, {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive'
    });
    
    const command = new ConverseStreamCommand({
      modelId: 'us.anthropic.claude-sonnet-4-20250514-v1:0',
      messages,
      system: systemPrompt ? [{ text: systemPrompt }] : [],
      inferenceConfig: {
        maxTokens: 8000,
        temperature: 0.2,  // Mas determinista para streaming
        topP: 0.4
      }
    });
    
    const response = await bedrockClient.send(command);
    let usage = null;
    
    // Procesar stream de respuesta
    for await (const chunk of response.stream) {
      if (chunk.contentBlockDelta?.delta?.text) {
        const text = chunk.contentBlockDelta.delta.text;
        res.write(`data: ${JSON.stringify({ 
          type: 'chunk', 
          content: text 
        })}\n\n`);
      }
      
      if (chunk.metadata?.usage) {
        usage = chunk.metadata.usage;
      }
    }
    
    // Enviar metricas finales
    if (usage) {
      res.write(`data: ${JSON.stringify({ 
        type: 'tokens', 
        usage 
      })}\n\n`);
    }
    
    res.write(`data: ${JSON.stringify({ type: 'end' })}\n\n`);
    res.end();
  } catch (error) {
    console.error('Error en chat streaming:', error);
    res.write(`data: ${JSON.stringify({ 
      type: 'error', 
      message: error.message 
    })}\n\n`);
    res.end();
  }
});
\end{lstlisting}

\paragraph{Generación de Iconos con Titan Image Generator}

El sistema genera iconos personalizados usando IA en un proceso de tres pasos:

\begin{enumerate}
\item \textbf{Traducción del prompt:} Usa Claude Haiku para traducir descripciones en español a inglés
\item \textbf{Generación de imagen:} Titan Image Generator V2 crea el icono en blanco y negro
\item \textbf{Almacenamiento:} La imagen se guarda en S3 para acceso posterior
\end{enumerate}

\begin{lstlisting}[ caption={Generación de iconos con IA}]
app.post('/api/generate-icon', async (req, res) => {
  try {
    const { prompt, bucket = 'irakani-app-builder', userId } = req.body;
    
    // PASO 1: Traducir prompt al ingles usando Claude Haiku
    const translateCommand = new ConverseCommand({
      modelId: 'us.anthropic.claude-3-5-haiku-20241022-v1:0',
      messages: [{
        role: 'user',
        content: [{
          text: `Translate this Spanish text to English for an 
                 icon description. Only return the English 
                 translation: ${prompt}`
        }]
      }],
      inferenceConfig: {
        maxTokens: 100,
        temperature: 0.1  // Muy determinista para traduccion
      }
    });
    
    const translateResult = await bedrockClient.send(translateCommand);
    const englishPrompt = 
      translateResult.output.message.content[0].text.trim();
    
    // PASO 2: Generar imagen con Titan
    const enhancedPrompt = `${englishPrompt} icon, black and white 
      only, solid black icon on pure white background. Monochrome 
      design, minimalist flat style, clean vector illustration, 
      modern app icon, centered composition, high contrast.`;
    
    const negativePrompt = `colors, gradient, shadows, 3d effects, 
      realistic, text, letters, watermark, blurry, low quality`;
    
    // Generar semilla deterministica
    const seed = Math.abs(prompt.split('').reduce((acc, char) => {
      return ((acc << 5) - acc) + char.charCodeAt(0);
    }, 0)) % 2147483647;
    
    const imageCommand = new InvokeModelCommand({
      modelId: 'amazon.titan-image-generator-v2:0',
      body: JSON.stringify({
        taskType: 'TEXT_IMAGE',
        textToImageParams: {
          text: enhancedPrompt,
          negativeText: negativePrompt
        },
        imageGenerationConfig: {
          numberOfImages: 1,
          height: 512,
          width: 512,
          cfgScale: 8.5,
          seed: seed,
          quality: 'premium'
        }
      })
    });
    
    const imageResult = await bedrockClient.send(imageCommand);
    const responseBody = 
      JSON.parse(new TextDecoder().decode(imageResult.body));
    
    // PASO 3: Subir imagen a S3
    const imageData = responseBody.images[0];
    const timestamp = Date.now();
    const iconKey = `icons/${userId || 'anonymous'}/${timestamp}.png`;
    
    const s3Command = new PutObjectCommand({
      Bucket: bucket,
      Key: iconKey,
      Body: Buffer.from(imageData, 'base64'),
      ContentType: 'image/png'
    });
    
    await s3Client.send(s3Command);
    
    const imageUrl = 
      `/api/image/${bucket}/${userId || 'anonymous'}/${timestamp}.png`;
    
    res.json({
      imageUrl,
      s3Key: iconKey,
      originalPrompt: prompt,
      translatedPrompt: englishPrompt
    });
  } catch (error) {
    console.error('Error generando icono:', error);
    res.status(500).json({ error: 'Error generando icono' });
  }
});
\end{lstlisting}

\paragraph{Autocompletado Inteligente de Código}

El sistema proporciona sugerencias contextuales de código usando Claude Haiku, optimizado para respuestas rápidas y económicas:

\begin{lstlisting}[ caption={Autocompletado asistido por IA}]
app.post('/api/ai/autocomplete', async (req, res) => {
  try {
    const { code, scriptType, currentJson } = req.body;
    
    const systemPrompt = `GENERADOR DE AUTOCOMPLETADO IRAKANI
Eres un experto en JavaScript ES6+ y la plataforma Irakani. 
Analiza el codigo y sugiere 2-3 autocompletados contextuales.

FUNCIONES IRAKANI:
- datosEspacio: Variables compartidas entre apps
- entidad: Info de entidad seleccionada
- obtenerEvento(): Obtiene evento actual
- colocarValor(id, valor): Establece valor de campo
- obtenerValor(id): Obtiene valor de campo
- siguienteFormulario(): Avanza al siguiente formulario
- notificar(texto): Muestra notificacion

Retorna JSON: [{"label": "nombre", "detail": "descripcion", 
                "code": "codigo"}]`;
    
    const contextInfo = currentJson ? 
      createResumedContext(currentJson) : '';
    
    const userMessage = `CODIGO ACTUAL:
${code}

TIPO DE SCRIPT: ${scriptType}
${contextInfo ? `\nCONTEXTO:\n${contextInfo}` : ''}

Analiza el codigo y sugiere autocompletados relevantes.`;
    
    const command = new ConverseCommand({
      modelId: 'us.anthropic.claude-haiku-4-5-20251001-v1:0',
      messages: [{ 
        role: 'user', 
        content: [{ text: userMessage }] 
      }],
      system: [{ text: systemPrompt }],
      inferenceConfig: {
        maxTokens: 3000,
        temperature: 0.3  // Baja creatividad para precision
      }
    });
    
    const result = await bedrockClient.send(command);
    const output = result.output.message.content[0].text.trim();
    
    // Extraer JSON del output
    const jsonMatch = output.match(/\[\s*\{[\s\S]*\}\s*\]/);
    const suggestions = jsonMatch ? JSON.parse(jsonMatch[0]) : [];
    
    res.json({ suggestions });
  } catch (error) {
    console.error('Error en autocomplete:', error);
    res.json({ suggestions: [] });
  }
});
\end{lstlisting}

\paragraph{Servicio de Registro de Uso}

Para trazabilidad y análisis de costos, se implementó un servicio que registra cada uso de IA en DynamoDB:

\begin{lstlisting}[ caption={Servicio de registro de uso de IA}]
// backend/services/UsageLogService.js
const { DynamoDBClient, PutItemCommand } = 
  require('@aws-sdk/client-dynamodb');

class UsageLogService {
  constructor() {
    this.dynamoClient = new DynamoDBClient({
      region: process.env.AWS_REGION || '[REGIÓN_AWS]'
    });
    this.tableName = 'IrakaniBuilderUsageLogs';
  }
  
  async logUsage(userId, inputTokens, outputTokens, model, 
                 schema, context, sessionId = null, imageCount = 0) {
    try {
      const timestamp = new Date().toISOString();
      const logId = `${userId}_${Date.now()}_${Math.random()
        .toString(36).substr(2, 9)}`;
      
      const cost = this.calculateCost(model, inputTokens, 
                                     outputTokens, imageCount);
      
      const command = new PutItemCommand({
        TableName: this.tableName,
        Item: {
          logId: { S: logId },
          userId: { S: userId },
          timestamp: { S: timestamp },
          model: { S: model },
          schema: { S: schema },
          context: { S: context },
          inputTokens: { N: inputTokens.toString() },
          outputTokens: { N: outputTokens.toString() },
          totalTokens: { N: (inputTokens + outputTokens).toString() },
          imageCount: { N: imageCount.toString() },
          cost: { N: cost.toFixed(6) },
          sessionId: sessionId ? { S: sessionId } : { NULL: true }
        }
      });
      
      await this.dynamoClient.send(command);
      console.log(`Uso registrado: ${model} - $${cost.toFixed(6)}`);
    } catch (error) {
      console.error('Error registrando uso:', error);
    }
  }
  
  calculateCost(model, inputTokens, outputTokens, imageCount) {
    const pricing = {
      'claude-sonnet-4': { input: [PRECIO_CENSURADO], output: [PRECIO_CENSURADO] },
      'claude-3-5-haiku': { input: [PRECIO_CENSURADO], output: [PRECIO_CENSURADO] },
      'titan-image-generator-v2': { perImage: [PRECIO_CENSURADO] }
    };
    
    const modelPricing = pricing[model];
    if (!modelPricing) return 0;
    
    if (model.includes('titan-image')) {
      return imageCount * modelPricing.perImage;
    }
    
    const inputCost = (inputTokens / 1000) * modelPricing.input;
    const outputCost = (outputTokens / 1000) * modelPricing.output;
    return inputCost + outputCost;
  }
}

module.exports = UsageLogService;
\end{lstlisting}

Este servicio permite:
\begin{itemize}
\item Trazabilidad completa de uso de modelos de IA
\item Análisis de costos por usuario, sesión y contexto
\item Optimización de uso de modelos según patrones detectados
\item Auditoría de operaciones de IA para cumplimiento
\end{itemize}

AWS Bedrock proporciona las capacidades de IA generativa del sistema. La integración incluye:

\textbf{Modelos Utilizados:}

\begin{itemize}
    \item \textbf{Claude Sonnet 4:} Modelo principal para generación de código y asistencia ([PRECIO CENSURADO])
    \item \textbf{Claude 3.5 Haiku:} Modelo alternativo para tareas más simples ([PRECIO CENSURADO])
    \item \textbf{Titan Image Generator V2:} Generación de iconos ([PRECIO CENSURADO])
\end{itemize}

\textbf{Servicios de IA Implementados:}

\begin{enumerate}
    \item \textbf{Chat Básico:} Endpoint \texttt{/api/chat/bedrock} que retorna respuesta completa con trazabilidad de tokens y costos
    
    \item \textbf{Chat con Streaming:} Endpoint \texttt{/api/chat/bedrock/stream} que utiliza Server-Sent Events (SSE) para respuestas en tiempo real, mejorando la percepción de velocidad
    
    \item \textbf{Generación de Iconos:} Endpoint \texttt{/api/generate-icon} que:
    \begin{itemize}
        \item Traduce prompts del español al inglés usando Claude Haiku
        \item Genera iconos en blanco y negro con Titan Image Generator
        \item Almacena resultados en S3
        \item Retorna métricas de uso y costos por operación
    \end{itemize}

\textbf{Sistema de Trazabilidad:}

Todas las operaciones de IA se registran en DynamoDB (tabla \texttt{IrakaniBuilderUsageLogs}) con:
\begin{itemize}
    \item Tokens de entrada y salida consumidos
    \item Modelo utilizado y costo calculado
    \item Usuario, contexto y timestamp de la operación
    \item Esquema de trabajo (espacio de Irakani)
\end{itemize}

\subsubsection{Desarrollo del Frontend}

El frontend de Irakani Builder está construido con React 18 y TypeScript, proporcionando una experiencia de usuario moderna y responsiva con capacidades avanzadas de edición visual y de código.

\paragraph{Stack Tecnológico Frontend}

El frontend utiliza un conjunto moderno de tecnologías:

\begin{table}[h]
\centering
\small
\begin{tabular}{|l|l|p{6cm}|}
\hline
\textbf{Tecnología} & \textbf{Versión} & \textbf{Propósito} \\
\hline
React & 18.2.0 & Framework principal de UI \\
TypeScript & 5.0.0 & Tipado estático y seguridad \\
Monaco Editor & 4.7.0 & Editor de código profesional \\
AWS Amplify & 6.15.1 & Autenticación con Cognito \\
Zustand & 5.0.6 & Gestión de estado ligera \\
ReactFlow & 11.11.4 & Editor visual de workflows \\
Fabric.js & 6.7.1 & Canvas para editor visual \\
Framer Motion & 10.16.0 & Animaciones fluidas \\
Vite & 7.0.0 & Build tool y dev server \\
\hline
\end{tabular}
\caption{Stack tecnológico del frontend}
\end{table}

\paragraph{Implementación del Editor Visual}

El editor visual permite diseñar aplicaciones mediante Fabric.js para manipulación de canvas:

\begin{lstlisting}[ caption={Componente principal del editor visual}]
// src/components/VisualEditor/VisualEditor.tsx
import React, { useState, useCallback } from 'react';
import { fabric } from 'fabric';
import { useEditorStore } from '../../stores/editorStore';

export const VisualEditor: React.FC = ({ 
  applicationData, 
  onUpdate 
}) => {
  const [canvas, setCanvas] = useState<fabric.Canvas | null>(null);
  const { selectedElement, setSelectedElement } = useEditorStore();
  
  // Inicializar canvas
  React.useEffect(() => {
    const fabricCanvas = new fabric.Canvas('visual-editor-canvas', {
      width: 800,
      height: 600,
      backgroundColor: '#f5f5f5'
    });
    
    setCanvas(fabricCanvas);
    
    return () => {
      fabricCanvas.dispose();
    };
  }, []);
  
  // Agregar elemento al canvas
  const addElement = useCallback((type: string) => {
    if (!canvas) return;
    
    let element: fabric.Object;
    
    switch (type) {
      case 'text':
        element = new fabric.IText('Texto', {
          left: 100,
          top: 100,
          fontSize: 16,
          fill: '#000000'
        });
        break;
        
      case 'button':
        const button = new fabric.Rect({
          left: 100, top: 100,
          width: 120, height: 40,
          fill: '#007bff',
          rx: 5, ry: 5
        });
        
        const buttonText = new fabric.Text('Boton', {
          left: 130, top: 110,
          fontSize: 14, fill: '#ffffff'
        });
        
        element = new fabric.Group([button, buttonText], {
          left: 100, top: 100
        });
        break;
        
      case 'input':
        element = new fabric.Rect({
          left: 100, top: 100,
          width: 200, height: 35,
          fill: '#ffffff',
          stroke: '#cccccc',
          strokeWidth: 1,
          rx: 3, ry: 3
        });
        break;
        
      default:
        return;
    }
    
    canvas.add(element);
    canvas.setActiveObject(element);
    canvas.renderAll();
    
    onUpdate(serializeCanvas(canvas));
  }, [canvas, onUpdate]);
  
  // Serializar canvas a JSON
  const serializeCanvas = (canvas: fabric.Canvas) => {
    return canvas.toJSON(['id', 'name', 'type', 'customData']);
  };
  
  return (
    <div className="visual-editor">
      <div className="toolbar">
        <button onClick={() => addElement('text')}>
          Agregar Texto
        </button>
        <button onClick={() => addElement('button')}>
          Agregar Boton
        </button>
        <button onClick={() => addElement('input')}>
          Agregar Input
        </button>
      </div>
      <canvas id="visual-editor-canvas" />
    </div>
  );
};
\end{lstlisting}

\paragraph{Implementación del Editor de Código con Monaco}

Monaco Editor proporciona una experiencia profesional con resaltado de sintaxis, autocompletado inteligente asistido por IA, y validación en tiempo real:

\begin{lstlisting}[ caption={Editor de código con autocompletado IA}]
// src/components/CodeEditor/CodeEditor.tsx
import React, { useRef, useState } from 'react';
import Editor, { Monaco } from '@monaco-editor/react';
import * as monaco from 'monaco-editor';
import { aiService } from '../../services/aiService';

export const CodeEditor: React.FC = ({
  value,
  language,
  onChange,
  theme = 'vs-dark',
  readOnly = false
}) => {
  const editorRef = useRef<monaco.editor.IStandaloneCodeEditor>(null);
  const [isLoadingAutocomplete, setIsLoadingAutocomplete] = 
    useState(false);
  
  const handleEditorDidMount = (
    editor: monaco.editor.IStandaloneCodeEditor,
    monaco: Monaco
  ) => {
    editorRef.current = editor;
    
    // Configurar autocompletado personalizado con IA
    monaco.languages.registerCompletionItemProvider('javascript', {
      provideCompletionItems: async (model, position) => {
        setIsLoadingAutocomplete(true);
        
        try {
          // Obtener codigo hasta la posicion actual
          const textUntilPosition = model.getValueInRange({
            startLineNumber: 1,
            startColumn: 1,
            endLineNumber: position.lineNumber,
            endColumn: position.column
          });
          
          // Solicitar sugerencias a la IA
          const suggestions = 
            await aiService.getAutocompleteSuggestions({
              code: textUntilPosition,
              scriptType: language,
              currentJson: null
            });
          
          // Convertir sugerencias a formato Monaco
          return {
            suggestions: suggestions.map((suggestion: any) => ({
              label: suggestion.label,
              kind: monaco.languages.CompletionItemKind.Function,
              detail: suggestion.detail,
              insertText: suggestion.code,
              insertTextRules: monaco.languages
                .CompletionItemInsertTextRule.InsertAsSnippet,
              documentation: suggestion.detail
            }))
          };
        } catch (error) {
          console.error('Error obteniendo autocompletado:', error);
          return { suggestions: [] };
        } finally {
          setIsLoadingAutocomplete(false);
        }
      },
      triggerCharacters: ['.', '(', ' ']
    });
    
    // Validacion en tiempo real
    editor.onDidChangeModelContent(() => {
      const value = editor.getValue();
      onChange(value);
    });
  };
  
  const editorOptions = {
    readOnly,
    minimap: { enabled: true },
    fontSize: 14,
    lineNumbers: 'on',
    automaticLayout: true,
    tabSize: 2,
    wordWrap: 'on',
    formatOnPaste: true,
    formatOnType: true,
    suggestOnTriggerCharacters: true,
    quickSuggestions: {
      other: true,
      comments: false,
      strings: true
    },
    parameterHints: { enabled: true },
    folding: true
  };
  
  return (
    <div className="code-editor-container">
      {isLoadingAutocomplete && (
        <div className="autocomplete-loading">
          Obteniendo sugerencias de IA...
        </div>
      )}
      <Editor
        height="600px"
        language={language}
        value={value}
        theme={theme}
        options={editorOptions}
        onMount={handleEditorDidMount}
      />
    </div>
  );
};
\end{lstlisting}

\paragraph{Servicio de Autenticación con AWS Cognito}

La integración con AWS Amplify proporciona autenticación segura:

\begin{lstlisting}[ caption={Servicio de autenticación}]
// src/services/authService.ts
import { Amplify } from 'aws-amplify';
import { signIn, signOut, getCurrentUser, 
         fetchAuthSession } from 'aws-amplify/auth';

// Configurar Amplify con Cognito
Amplify.configure({
  Auth: {
    Cognito: {
      userPoolId: import.meta.env.VITE_USER_POOL_ID,
      userPoolClientId: import.meta.env.VITE_USER_POOL_CLIENT_ID,
      identityPoolId: import.meta.env.VITE_IDENTITY_POOL_ID,
      region: import.meta.env.VITE_AWS_REGION || '[REGIÓN_AWS]'
    }
  }
});

export class AuthService {
  async login(username: string, password: string) {
    try {
      const user = await signIn({ username, password });
      console.log('Login exitoso:', user);
      return user;
    } catch (error) {
      console.error('Error en login:', error);
      throw error;
    }
  }
  
  async logout() {
    try {
      await signOut();
      console.log('Logout exitoso');
    } catch (error) {
      console.error('Error en logout:', error);
      throw error;
    }
  }
  
  async getCurrentUser() {
    try {
      const user = await getCurrentUser();
      return user;
    } catch (error) {
      return null;
    }
  }
  
  async getAuthToken(): Promise<string | null> {
    try {
      const session = await fetchAuthSession();
      return session.tokens?.idToken?.toString() || null;
    } catch (error) {
      return null;
    }
  }
  
  async getAWSCredentials() {
    try {
      const session = await fetchAuthSession();
      return session.credentials;
    } catch (error) {
      return null;
    }
  }
}

export const authService = new AuthService();
\end{lstlisting}

\paragraph{Servicio de IA para el Frontend}

El servicio encapsula todas las interacciones con el backend de IA:

\begin{lstlisting}[ caption={Servicio de IA del frontend}]
// src/services/aiService.ts
import axios from 'axios';
import { authService } from './authService';

const API_BASE_URL = import.meta.env.VITE_API_URL || 
                     '[URL_BACKEND_LOCAL]';

export class AIService {
  private axiosInstance;
  
  constructor() {
    this.axiosInstance = axios.create({
      baseURL: API_BASE_URL,
      timeout: 60000,
      headers: { 'Content-Type': 'application/json' }
    });
    
    // Interceptor para agregar token de autenticacion
    this.axiosInstance.interceptors.request.use(
      async (config) => {
        const token = await authService.getAuthToken();
        if (token) {
          config.headers.Authorization = `Bearer ${token}`;
        }
        
        const user = await authService.getCurrentUser();
        if (user) {
          config.headers['x-user-id'] = user.username;
        }
        
        return config;
      }
    );
  }
  
  async chat(messages: any[], systemPrompt?: string) {
    const response = await this.axiosInstance.post(
      '/api/chat/bedrock',
      { messages, systemPrompt },
      { headers: { 'x-context': 'chat', 'x-schema': 'general-chat' } }
    );
    return response.data;
  }
  
  async chatStream(
    messages: any[],
    systemPrompt: string | undefined,
    onChunk: (chunk: string) => void,
    onTokens?: (usage: any) => void
  ) {
    const user = await authService.getCurrentUser();
    const token = await authService.getAuthToken();
    
    const response = await fetch(
      `${API_BASE_URL}/api/chat/bedrock/stream`,
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`,
          'x-user-id': user?.username || 'anonymous'
        },
        body: JSON.stringify({ messages, systemPrompt })
      }
    );
    
    const reader = response.body?.getReader();
    const decoder = new TextDecoder();
    
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      
      const chunk = decoder.decode(value);
      const lines = chunk.split('\n');
      
      for (const line of lines) {
        if (line.startsWith('data: ')) {
          const data = JSON.parse(line.slice(6));
          
          if (data.type === 'chunk') {
            onChunk(data.content);
          } else if (data.type === 'tokens' && onTokens) {
            onTokens(data.usage);
          } else if (data.type === 'end') {
            return;
          }
        }
      }
    }
  }
  
  async generateIcon(prompt: string, userId?: string) {
    const response = await this.axiosInstance.post(
      '/api/generate-icon',
      { prompt, userId, bucket: 'irakani-app-builder' }
    );
    return response.data;
  }
  
  async getAutocompleteSuggestions(params: {
    code: string;
    scriptType: string;
    currentJson: any;
  }) {
    try {
      const response = await this.axiosInstance.post(
        '/api/ai/autocomplete',
        params
      );
      return response.data.suggestions || [];
    } catch (error) {
      return [];
    }
  }
  
  async generateApplication(prompt: string, options?: any) {
    const response = await this.axiosInstance.post(
      '/api/generate',
      { prompt, ...options }
    );
    return response.data;
  }
}

export const aiService = new AIService();
\end{lstlisting}

\paragraph{Gestión de Estado con Zustand}

Zustand proporciona gestión de estado ligera y eficiente:

\begin{lstlisting}[ caption={Store de estado del editor}]
// src/stores/editorStore.ts
import { create } from 'zustand';

interface EditorState {
  currentApplication: any | null;
  isModified: boolean;
  selectedElement: any | null;
  editorMode: 'visual' | 'code';
  isChatOpen: boolean;
  chatMessages: any[];
  isGenerating: boolean;
  
  setCurrentApplication: (app: any) => void;
  setIsModified: (modified: boolean) => void;
  setSelectedElement: (element: any) => void;
  setEditorMode: (mode: 'visual' | 'code') => void;
  toggleChat: () => void;
  addChatMessage: (message: any) => void;
  setIsGenerating: (generating: boolean) => void;
  resetEditor: () => void;
}

export const useEditorStore = create<EditorState>((set) => ({
  currentApplication: null,
  isModified: false,
  selectedElement: null,
  editorMode: 'visual',
  isChatOpen: false,
  chatMessages: [],
  isGenerating: false,
  
  setCurrentApplication: (app) => 
    set({ currentApplication: app }),
  setIsModified: (modified) => 
    set({ isModified: modified }),
  setSelectedElement: (element) => 
    set({ selectedElement: element }),
  setEditorMode: (mode) => 
    set({ editorMode: mode }),
  toggleChat: () => 
    set((state) => ({ isChatOpen: !state.isChatOpen })),
  addChatMessage: (message) => 
    set((state) => ({
      chatMessages: [...state.chatMessages, message]
    })),
  setIsGenerating: (generating) => 
    set({ isGenerating: generating }),
  resetEditor: () => set({
    currentApplication: null,
    isModified: false,
    selectedElement: null,
    editorMode: 'visual',
    isChatOpen: false,
    chatMessages: [],
    isGenerating: false
  })
}));
\end{lstlisting}

\paragraph{Componente de Chat con IA}

El panel de chat proporciona interacción en tiempo real con el asistente de IA:

\begin{lstlisting}[ caption={Panel de chat con streaming}]
// src/components/ChatPanel/ChatPanel.tsx
import React, { useState, useRef, useEffect } from 'react';
import { aiService } from '../../services/aiService';
import { useEditorStore } from '../../stores/editorStore';

export const ChatPanel: React.FC = ({ onGenerate, isGenerating }) => {
  const { chatMessages, addChatMessage } = useEditorStore();
  const [input, setInput] = useState('');
  const [isStreaming, setIsStreaming] = useState(false);
  const [currentStreamMessage, setCurrentStreamMessage] = useState('');
  const messagesEndRef = useRef<HTMLDivElement>(null);
  
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [chatMessages, currentStreamMessage]);
  
  const handleSend = async () => {
    if (!input.trim() || isStreaming) return;
    
    const userMessage = {
      role: 'user',
      content: input,
      timestamp: new Date().toISOString()
    };
    
    addChatMessage(userMessage);
    setInput('');
    setIsStreaming(true);
    setCurrentStreamMessage('');
    
    try {
      const messages = [
        ...chatMessages.map(msg => ({
          role: msg.role,
          content: [{ text: msg.content }]
        })),
        {
          role: 'user',
          content: [{ text: input }]
        }
      ];
      
      const systemPrompt = `Eres un asistente experto en desarrollo 
        de aplicaciones con Irakani Builder. Ayuda al usuario a crear, 
        modificar y optimizar aplicaciones.`;
      
      await aiService.chatStream(
        messages,
        systemPrompt,
        (chunk) => {
          setCurrentStreamMessage(prev => prev + chunk);
        },
        (usage) => {
          console.log('Uso de tokens:', usage);
        }
      );
      
      const assistantMessage = {
        role: 'assistant',
        content: currentStreamMessage,
        timestamp: new Date().toISOString()
      };
      
      addChatMessage(assistantMessage);
      setCurrentStreamMessage('');
      setIsStreaming(false);
    } catch (error) {
      console.error('Error en chat:', error);
      setIsStreaming(false);
    }
  };
  
  return (
    <div className="chat-panel">
      <div className="chat-header">
        <h3>Asistente IA</h3>
      </div>
      
      <div className="chat-messages">
        {chatMessages.map((message, index) => (
          <div key={index} className={`message ${message.role}`}>
            <div className="message-avatar">
              {message.role === 'user' ? '👤' : '🤖'}
            </div>
            <div className="message-content">
              <div className="message-text">{message.content}</div>
              <div className="message-timestamp">
                {new Date(message.timestamp).toLocaleTimeString()}
              </div>
            </div>
          </div>
        ))}
        
        {isStreaming && currentStreamMessage && (
          <div className="message assistant streaming">
            <div className="message-avatar">🤖</div>
            <div className="message-content">
              <div className="message-text">
                {currentStreamMessage}
                <span className="cursor">▊</span>
              </div>
            </div>
          </div>
        )}
        
        <div ref={messagesEndRef} />
      </div>
      
      <div className="chat-input-container">
        <textarea
          className="chat-input"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Escribe tu mensaje..."
          disabled={isStreaming}
          rows={3}
        />
        <button
          className="send-button"
          onClick={handleSend}
          disabled={!input.trim() || isStreaming}
        >
          {isStreaming ? '⏳' : '📤'} Enviar
        </button>
      </div>
      
      <div className="quick-actions">
        <button onClick={() => 
          setInput('Crea una aplicacion de gestion de inventario')}>
          📦 Inventario
        </button>
        <button onClick={() => 
          setInput('Genera un formulario de registro de usuarios')}>
          📝 Formulario
        </button>
        <button onClick={() => 
          setInput('Optimiza el codigo de mi aplicacion')}>
          ⚡ Optimizar
        </button>
      </div>
    </div>
  );
};
\end{lstlisting}

El frontend integra todas estas tecnologías para proporcionar una experiencia de desarrollo completa, con edición visual y de código, asistencia de IA en tiempo real, y autenticación segura con AWS Cognito.

El frontend está construido con React 18 y TypeScript, proporcionando una experiencia de usuario moderna y responsiva.

\textbf{Stack Tecnológico del Frontend:}

\begin{itemize}
    \item \textbf{Framework:} React 18 con TypeScript
    \item \textbf{Editor de Código:} @monaco-editor/react (Monaco Editor)
    \item \textbf{Autenticación:} AWS Amplify con AWS Cognito
    \item \textbf{Gestión de Estado:} Zustand
    \item \textbf{Editor Visual:} ReactFlow y Fabric.js
    \item \textbf{Animaciones:} Framer Motion
    \item \textbf{Build Tool:} Vite
\end{itemize}

\textbf{Componentes Principales:}

\begin{enumerate}
    \item \textbf{Editor Visual:} Componente basado en Fabric.js que permite diseñar aplicaciones con elementos (texto, botones, inputs), con serialización a JSON
    
    \item \textbf{Editor de Código (Monaco):} Integración completa del editor de Visual Studio Code con:
    \begin{itemize}
        \item Resaltado de sintaxis para JSON, JavaScript, SQL, HTML
        \item Autocompletado inteligente asistido por IA
        \item Validación en tiempo real
        \item Más de 20 temas personalizables (Monokai, Dracula, GitHub, etc.)
        \item Atajos de teclado personalizados (Ctrl+S para guardar)
    \end{itemize}
    
    \item \textbf{Panel de Chat con IA:} Interfaz de conversación que:
    \begin{itemize}
        \item Mantiene historial de conversación persistente
        \item Soporta streaming de respuestas en tiempo real
        \item Muestra métricas de tokens consumidos
        \item Incluye sugerencias rápidas predefinidas
        \item Aplica cambios sugeridos automáticamente al JSON
    \end{itemize}
\end{enumerate}

\textbf{Servicios del Frontend:}

\begin{enumerate}
    \item \textbf{AuthService:} Gestión de autenticación con AWS Cognito mediante Amplify, incluyendo login, logout, obtención de tokens y credenciales AWS temporales
    
    \item \textbf{AIService:} Cliente centralizado para todas las interacciones con IA que:
    \begin{itemize}
        \item Agrega automáticamente tokens de autenticación a las peticiones
        \item Implementa chat básico y con streaming
        \item Gestiona generación de iconos y autocompletado
        \item Incluye headers de trazabilidad (x-user-id, x-context, x-schema)
    \end{itemize}
    
    \item \textbf{EditorStore (Zustand):} Gestión centralizada del estado de la aplicación, incluyendo:
    \begin{itemize}
        \item Aplicación actual y estado de modificación
        \item Elemento seleccionado y modo de editor (visual/código)
        \item Estado del chat (abierto/cerrado, mensajes, generando)
        \item Acciones para manipular el estado
    \end{itemize}
\end{enumerate}

\subsection{Planificación de Sprints}

Esta sección detalla la ejecución de cada sprint, documentando los objetivos, historias de usuario implementadas, resultados obtenidos y lecciones aprendidas durante el desarrollo del proyecto.

\subsubsection{Sprint 0: Concepción y Diseño (14-27 julio 2025)}

\textbf{Sprint Goal:} Establecer las bases técnicas y arquitectónicas del proyecto.

\textbf{Historias de Usuario Implementadas:}
\begin{itemize}
    \item HU-001: Configuración del Entorno de Desarrollo (5 SP)
    \item HU-002: Definición de Arquitectura de Microservicios (8 SP)
\end{itemize}

\textbf{Resultados Obtenidos:}
\begin{itemize}
    \item Repositorio Git configurado en Bitbucket con estructura de carpetas
    \item Pipeline CI/CD básico implementado
    \item Diagrama de arquitectura de microservicios documentado
    \item Stack tecnológico validado: React 18, Node.js, AWS Bedrock, Valkey
    \item Definición de endpoints RESTful principales
    \item Documentación inicial en README.md
\end{itemize}

\textbf{Métricas del Sprint:}
\begin{itemize}
    \item Story Points Completados: 13/13 (100\%)
    \item Velocidad del Sprint: 13 SP
    \item Historias Completadas: 2/2
\end{itemize}

\textbf{Lecciones Aprendidas:}
\begin{itemize}
    \item \textit{Inversión inicial en infraestructura:} Dedicar tiempo suficiente a la configuración del entorno y CI/CD desde el inicio previene problemas de integración posteriores y facilita el desarrollo iterativo.
    \item \textit{Documentación de arquitectura:} La definición clara de la arquitectura de microservicios y sus interfaces desde el Sprint 0 permitió que el equipo tuviera una visión compartida del sistema, reduciendo ambigüedades en sprints posteriores.
    \item \textit{Validación temprana del stack tecnológico:} Realizar pruebas de concepto con AWS Bedrock y Valkey en este sprint evitó sorpresas técnicas durante la implementación de funcionalidades críticas.
    \item \textit{Estimación conservadora:} Las estimaciones iniciales fueron precisas debido a la experiencia previa del equipo con tecnologías similares, estableciendo una baseline confiable para la velocidad del equipo.
\end{itemize}


\subsubsection{Sprint 1: Autenticación y Seguridad (28 julio - 10 agosto 2025)}

\textbf{Sprint Goal:} Implementar sistema de autenticación seguro con AWS Cognito.

\textbf{Historias de Usuario Implementadas:}
\begin{itemize}
    \item HU-003: Sistema de Autenticación con JWT (8 SP)
\end{itemize}

\textbf{Resultados Obtenidos:}
\begin{itemize}
    \item Integración con AWS Cognito completada
    \item Endpoints de autenticación funcionales (/api/auth/login, /api/auth/register)
    \item Generación y validación de tokens JWT
    \item Middleware de autenticación en Node.js
    \item Gestión de sesiones con Valkey
    \item Pruebas unitarias con cobertura >80\%
\end{itemize}

\textbf{Métricas del Sprint:}
\begin{itemize}
    \item Story Points Completados: 8/8 (100\%)
    \item Velocidad del Sprint: 8 SP
    \item Historias Completadas: 1/1
\end{itemize}

\textbf{Lecciones Aprendidas:}
\begin{itemize}
    \item \textit{Complejidad de AWS Cognito:} La curva de aprendizaje de AWS Cognito fue mayor a la estimada inicialmente. La configuración de user pools y la integración con JWT requirió más tiempo de investigación, lo que justificó la estimación de 8 SP.
    \item \textit{Importancia de Valkey para sesiones:} La decisión de usar Valkey para gestión de sesiones demostró ser acertada, proporcionando tiempos de respuesta <50ms y facilitando la invalidación de tokens.
    \item \textit{Testing de seguridad:} Implementar pruebas de seguridad desde el primer sprint de funcionalidad estableció un estándar de calidad que se mantuvo en sprints posteriores. La cobertura >80\% se convirtió en requisito mínimo.
    \item \textit{Documentación de APIs:} Documentar los endpoints de autenticación con ejemplos de uso facilitó la integración del frontend en sprints posteriores y redujo consultas entre equipos.
\end{itemize}


\subsubsection{Sprint 2: Núcleo de IA (11-24 agosto 2025)}

\textbf{Sprint Goal:} Integrar AWS Bedrock y desarrollar sistema de prompts.

\textbf{Historias de Usuario Implementadas:}
\begin{itemize}
    \item HU-004: Integración con AWS Bedrock (13 SP)
    \item HU-005: Ingeniería de Prompts (13 SP)
\end{itemize}

\textbf{Resultados Obtenidos:}
\begin{itemize}
    \item Cliente AWS Bedrock configurado
    \item Endpoint /api/ai/generate funcional
    \item Meta-prompts con técnicas Few-shot y Chain-of-Thought
    \item Validación de esquema JSON de salida
    \item Tasa de éxito >85\% en generación de estructuras válidas
    \item Manejo de errores y reintentos automáticos
    \item Logging de tokens consumidos y costos
\end{itemize}

\textbf{Métricas del Sprint:}
\begin{itemize}
    \item Story Points Completados: 26/26 (100\%)
    \item Velocidad del Sprint: 26 SP
    \item Historias Completadas: 2/2
\end{itemize}

\textbf{Lecciones Aprendidas:}
\begin{itemize}
    \item \textit{Iteración en ingeniería de prompts:} Alcanzar una tasa de éxito >85\% requirió múltiples iteraciones de refinamiento de prompts. La técnica Chain-of-Thought mejoró significativamente la calidad de las estructuras generadas, especialmente en casos complejos.
    \item \textit{Validación de esquemas JSON:} Implementar validación estricta de esquemas desde el inicio evitó problemas de integración con el frontend. Los reintentos automáticos ante respuestas inválidas mejoraron la experiencia del usuario.
    \item \textit{Monitoreo de costos de IA:} El logging detallado de tokens consumidos permitió identificar oportunidades de optimización tempranamente. Se detectó que ciertos prompts consumían 3x más tokens sin mejora proporcional en calidad.
    \item \textit{Velocidad del equipo:} El incremento significativo en la velocidad (de 8 SP a 26 SP) reflejó la familiarización del equipo con el stack tecnológico y la infraestructura establecida en sprints anteriores.
\end{itemize}


\subsubsection{Sprint 3: Interfaz Base (25 agosto - 7 septiembre 2025)}

\textbf{Sprint Goal:} Desarrollar interfaz de usuario base con React 18.

\textbf{Historias de Usuario Implementadas:}
\begin{itemize}
    \item HU-006: Interfaz de Usuario con React 18 (13 SP)
\end{itemize}

\textbf{Resultados Obtenidos:}
\begin{itemize}
    \item Componentes React con TypeScript implementados
    \item Sistema de routing con React Router
    \item Diseño responsivo con CSS Grid y Flexbox
    \item Sistema de temas personalizable (>20 temas)
    \item Componentes base reutilizables (botones, inputs, modales)
    \item Integración con Valkey para persistencia de preferencias
\end{itemize}

\textbf{Métricas del Sprint:}
\begin{itemize}
    \item Story Points Completados: 13/13 (100\%)
    \item Velocidad del Sprint: 13 SP
    \item Historias Completadas: 1/1
\end{itemize}

\textbf{Lecciones Aprendidas:}
\begin{itemize}
    \item \textit{TypeScript desde el inicio:} La decisión de usar TypeScript en lugar de JavaScript puro previno numerosos errores en tiempo de desarrollo. El tipado estricto facilitó el refactoring y mejoró la mantenibilidad del código.
    \item \textit{Sistema de diseño modular:} Crear componentes base reutilizables desde el principio aceleró el desarrollo en sprints posteriores. La inversión inicial en componentes genéricos se amortizó rápidamente.
    \item \textit{Personalización de temas:} Implementar >20 temas desde el inicio generó entusiasmo en stakeholders y usuarios beta. La persistencia en Valkey garantizó una experiencia consistente entre sesiones.
\end{itemize}


\subsubsection{Sprint 4: Editor Visual (8-21 septiembre 2025)}

\textbf{Sprint Goal:} Implementar editor visual y Monaco Editor.

\textbf{Historias de Usuario Implementadas:}
\begin{itemize}
    \item HU-007: Editor Visual (21 SP)
    \item HU-008: Integración de Monaco Editor (13 SP)
\end{itemize}

\textbf{Resultados Obtenidos:}
\begin{itemize}
    \item Editor visual con paleta de componentes
    \item Panel de propiedades contextual
    \item Monaco Editor integrado con syntax highlighting
    \item Autocompletado y validación en tiempo real
    \item Sincronización bidireccional vista visual-código
    \item Tree View para navegación de estructura JSON
    \item Guardado automático cada 500ms
\end{itemize}

\textbf{Métricas del Sprint:}
\begin{itemize}
    \item Story Points Completados: 34/34 (100\%)
    \item Velocidad del Sprint: 34 SP
    \item Historias Completadas: 2/2
\end{itemize}

\textbf{Lecciones Aprendidas:}
\begin{itemize}
    \item \textit{Complejidad de sincronización bidireccional:} La sincronización entre vista visual y código resultó más compleja de lo estimado. Se requirió implementar un sistema de eventos robusto para evitar loops infinitos y garantizar consistencia.
    \item \textit{Monaco Editor como biblioteca externa:} La integración de Monaco Editor demostró el valor de usar bibliotecas maduras. El syntax highlighting y autocompletado out-of-the-box ahorraron semanas de desarrollo.
    \item \textit{Incremento sostenido de velocidad:} El equipo alcanzó 34 SP, su mayor velocidad hasta el momento, indicando madurez en el proceso y familiaridad con el dominio del problema.
\end{itemize}


\subsubsection{Sprint 5: Renderizado y Bases de Datos (22 septiembre - 5 octubre 2025)}

\textbf{Sprint Goal:} Implementar renderizado de componentes y conexión a bases de datos.

\textbf{Historias de Usuario Implementadas:}
\begin{itemize}
    \item HU-009: Transformación JSON a Componentes Visuales (13 SP)
    \item HU-010: Conexión Multi-Motor de Base de Datos (8 SP)
\end{itemize}

\textbf{Resultados Obtenidos:}
\begin{itemize}
    \item Algoritmo de parsing JSON a componentes React
    \item Renderizado dinámico de formularios
    \item Servicios de conexión a MySQL y SQL Server
    \item Pool de conexiones optimizado
    \item Endpoint /api/database/connect funcional
    \item Manejo de errores de conexión y timeout
\end{itemize}

\textbf{Métricas del Sprint:}
\begin{itemize}
    \item Story Points Completados: 21/21 (100\%)
    \item Velocidad del Sprint: 21 SP
    \item Historias Completadas: 2/2
\end{itemize}

\textbf{Lecciones Aprendidas:}
\begin{itemize}
    \item \textit{Renderizado dinámico de componentes:} El algoritmo de parsing JSON a componentes React requirió un diseño flexible para soportar componentes anidados y validaciones complejas. La arquitectura basada en factory pattern facilitó la extensibilidad.
    \item \textit{Manejo de timeouts:} Los timeouts de conexión a bases de datos externas fueron más frecuentes de lo esperado. Implementar reintentos automáticos y mensajes de error claros mejoró la experiencia del usuario.
\end{itemize}


\subsubsection{Sprint 6: Gestión de Datos Avanzada (6-19 octubre 2025)}

\textbf{Sprint Goal:} Desarrollar administrador de base de datos con IA.

\textbf{Historias de Usuario Implementadas:}
\begin{itemize}
    \item HU-011: Administrador de Base de Datos Asistido por IA (13 SP)
\end{itemize}

\textbf{Resultados Obtenidos:}
\begin{itemize}
    \item Interfaz de DB Admin completa
    \item Explorador de tablas y esquemas
    \item Editor de consultas SQL con autocompletado
    \item Generación de queries desde lenguaje natural
    \item Visualización de resultados con paginación
    \item Exportación de datos (CSV, JSON, Excel)
\end{itemize}

\textbf{Métricas del Sprint:}
\begin{itemize}
    \item Story Points Completados: 13/13 (100\%)
    \item Velocidad del Sprint: 13 SP
    \item Historias Completadas: 1/1
\end{itemize}

\textbf{Lecciones Aprendidas:}
\begin{itemize}
    \item \textit{IA para generación de SQL:} La generación de queries SQL desde lenguaje natural fue una de las funcionalidades más valoradas por usuarios beta. Sin embargo, requirió validación estricta para prevenir queries destructivas (DELETE, DROP).
    \item \textit{Autocompletado contextual:} Implementar autocompletado basado en el esquema de la base de datos conectada mejoró significativamente la productividad. Los usuarios reportaron reducción del 40\% en tiempo de escritura de queries.
    \item \textit{Paginación de resultados:} La paginación fue crítica para manejar consultas que retornan miles de registros. Sin ella, el navegador se congelaba con resultados >1000 filas.
\end{itemize}


\subsubsection{Sprint 7: Asistente de Chat y Sesiones (20 octubre - 2 noviembre 2025)}

\textbf{Sprint Goal:} Implementar chat con IA y sistema de sesiones.

\textbf{Historias de Usuario Implementadas:}
\begin{itemize}
    \item HU-012: Chat de Asistencia con IA (13 SP)
    \item HU-013: Guardado y Recuperación de Sesiones (8 SP)
\end{itemize}

\textbf{Resultados Obtenidos:}
\begin{itemize}
    \item Interfaz de chat integrada
    \item Streaming de respuestas en tiempo real
    \item Contexto de conversación mantenido
    \item Sistema de sesiones múltiples
    \item Endpoints /api/sessions/save y /api/sessions/load
    \item Persistencia en Valkey y S3
    \item Gestión de sesiones por usuario
\end{itemize}

\textbf{Métricas del Sprint:}
\begin{itemize}
    \item Story Points Completados: 21/21 (100\%)
    \item Velocidad del Sprint: 21 SP
    \item Historias Completadas: 2/2
\end{itemize}

\textbf{Lecciones Aprendidas:}
\begin{itemize}
    \item \textit{Streaming de respuestas:} Implementar streaming en lugar de esperar la respuesta completa mejoró dramáticamente la percepción de velocidad. Los usuarios reportaron que el sistema se sentía más responsivo, aunque el tiempo total de respuesta era similar.
    \item \textit{Contexto de conversación:} Mantener el contexto de conversación fue más complejo de lo esperado. Se requirió un sistema de ventana deslizante para limitar tokens enviados a Bedrock mientras se preservaba coherencia.
    \item \textit{Arquitectura híbrida de persistencia:} Usar Valkey para sesiones activas y S3 para almacenamiento a largo plazo optimizó costos y rendimiento. Valkey proporcionó acceso rápido (<10ms) mientras S3 redujo costos de almacenamiento en 70\%.
    \item \textit{Gestión multi-sesión:} Permitir múltiples sesiones por usuario desde el inicio facilitó casos de uso donde los usuarios trabajan en varios proyectos simultáneamente.
\end{itemize}


\subsubsection{Sprint 8: Gestión de Componentes (3-16 noviembre 2025)}

\textbf{Sprint Goal:} Implementar gestión de aplicaciones creadas.

\textbf{Historias de Usuario Implementadas:}
\begin{itemize}
    \item HU-014: Gestión de componentes de Usuario (5 SP)
\end{itemize}

\textbf{Resultados Obtenidos:}
\begin{itemize}
    \item Endpoint /api/apps/list con paginación
    \item Interfaz de tarjetas de aplicaciones
    \item Operaciones CRUD: editar, duplicar, eliminar
    \item Confirmaciones para acciones destructivas
    \item Integración con DynamoDB para metadatos
    \item Versionamiento de aplicaciones en S3
\end{itemize}

\textbf{Métricas del Sprint:}
\begin{itemize}
    \item Story Points Completados: 5/5 (100\%)
    \item Velocidad del Sprint: 5 SP
    \item Historias Completadas: 1/1
\end{itemize}

\textbf{Lecciones Aprendidas:}
\begin{itemize}
    \item \textit{Sprint de menor complejidad:} Con solo 5 SP, este fue el sprint más ligero del proyecto. Permitió al equipo enfocarse en calidad y refactoring de código técnico acumulado en sprints anteriores.
    \item \textit{Versionamiento crítico:} Implementar versionamiento de aplicaciones desde el inicio previno pérdidas de trabajo. Los usuarios valoraron poder revertir a versiones anteriores cuando experimentaban con cambios.
    \item \textit{DynamoDB para metadatos:} Usar DynamoDB para metadatos de aplicaciones (nombre, fecha, usuario) y S3 para contenido completo demostró ser una arquitectura eficiente. Las consultas de listado fueron rápidas (<100ms) sin cargar JSONs completos.
    \item \textit{UX de confirmaciones:} Las confirmaciones para acciones destructivas (eliminar) redujeron errores de usuario en 95\%. Implementar modales claros con preview del contenido a eliminar fue clave.
\end{itemize}


\subsubsection{Sprint 9: Personalización (17-30 noviembre 2025)}

\textbf{Sprint Goal:} Implementar sistema de temas personalizable.

\textbf{Historias de Usuario Implementadas:}
\begin{itemize}
    \item HU-015: Sistema de Temas Personalizable (5 SP)
\end{itemize}

\textbf{Resultados Obtenidos:}
\begin{itemize}
    \item Selector de temas en configuración
    \item 20+ temas predefinidos (Monokai, Dracula, GitHub, Nord, etc.)
    \item Persistencia de preferencias en Valkey
    \item Aplicación inmediata sin recarga
    \item Vista previa de temas
    \item Variables CSS para tematización
\end{itemize}

\textbf{Métricas del Sprint:}
\begin{itemize}
    \item Story Points Completados: 5/5 (100\%)
    \item Velocidad del Sprint: 5 SP
    \item Historias Completadas: 1/1
\end{itemize}

\textbf{Lecciones Aprendidas:}
\begin{itemize}
    \item \textit{Variables CSS para tematización:} Usar variables CSS en lugar de clases específicas por tema facilitó enormemente la implementación. Un solo cambio de variables aplicaba el tema completo sin necesidad de recargar componentes.
    \item \textit{Vista previa de temas:} Permitir vista previa antes de aplicar el tema redujo la fricción en la selección. Los usuarios experimentaron con múltiples temas sin comprometer su configuración actual.
    \item \textit{Temas populares:} Los temas más solicitados fueron Dracula, Monokai y GitHub Dark, representando el 65\% de las selecciones. Esto validó la investigación previa sobre preferencias de desarrolladores.
    \item \textit{Aplicación sin recarga:} Implementar cambio de tema sin recarga de página mejoró significativamente la experiencia. La transición suave entre temas fue especialmente apreciada por usuarios.
\end{itemize}


\subsubsection{Sprint 10: Despliegue y Validación Final (1-14 diciembre 2025)}

\textbf{Sprint Goal:} Desplegar en producción y ejecutar pruebas finales.

\textbf{Historias de Usuario Implementadas:}
\begin{itemize}
    \item HU-016: Despliegue en Producción (13 SP)
    \item HU-017: Pruebas de Integración Final (8 SP)
\end{itemize}

\textbf{Resultados Obtenidos:}
\begin{itemize}
    \item Pipeline CI/CD completo con 6 etapas
    \item CodeBuild projects configurados (Frontend, Backend, Deploy, AMI, ASG)
    \item ECR para imágenes Docker
    \item Auto Scaling Group con Target Groups
    \item Suite de pruebas de integración
    \item Pruebas end-to-end de flujos críticos
    \item Cobertura de pruebas >80\%
\end{itemize}

\textbf{Métricas del Sprint:}
\begin{itemize}
    \item Story Points Completados: 21/21 (100\%)
    \item Velocidad del Sprint: 21 SP
    \item Historias Completadas: 2/2
\end{itemize}

\textbf{Lecciones Aprendidas:}
\begin{itemize}
    \item \textit{Pipeline CI/CD de 6 etapas:} La inversión en un pipeline robusto desde el Sprint 0 culminó en un despliegue sin incidentes. La automatización completa (source, build, deploy, ManualApprovaltoProduction, AMI, ASG) eliminó errores manuales.
    \item \textit{Pruebas end-to-end críticas:} Las pruebas E2E de flujos críticos detectaron 3 bugs de integración que no fueron capturados por pruebas unitarias. Esto validó la importancia de testing en múltiples niveles.
    \item \textit{Auto Scaling preparado:} Configurar Auto Scaling antes del lanzamiento fue crucial. Durante las pruebas de carga, el sistema escaló automáticamente de 2 a 8 instancias sin intervención manual.
    \item \textit{Cobertura de pruebas >80\%:} Mantener este estándar a lo largo del proyecto redujo bugs en producción. El equipo estimó que previno al menos 15-20 defectos críticos.
\end{itemize}


\subsubsection{Sprint 11: Buffer y Cierre (15-19 diciembre 2025)}

\textbf{Sprint Goal:} Resolver deuda técnica y preparar entrega final.

\textbf{Historias de Usuario Implementadas:}
\begin{itemize}
    \item HU-018: Resolver Deuda Técnica y Preparar Entrega Final (8 SP)
\end{itemize}

\textbf{Resultados Obtenidos:}
\begin{itemize}
    \item Refactorización de código con deuda técnica
    \item Optimización de rendimiento en áreas críticas
    \item Documentación técnica completa (README, guías)
    \item Documentación de usuario final
    \item Videos demo de funcionalidades principales
    \item Presentación final preparada
    \item Entrega de código fuente y artefactos
\end{itemize}

\textbf{Métricas del Sprint:}Pipeline CI/CD de 6 etapas:
\begin{itemize}
    \item Story Points Completados: 8/8 (100\%)
    \item Velocidad del Sprint: 8 SP
    \item Historias Completadas: 1/1
\end{itemize}

\textbf{Lecciones Aprendidas:}
\begin{itemize}
    \item \textit{Valor del sprint buffer:} Dedicar un sprint corto (5 días) al cierre permitió entregar un producto pulido. La refactorización de deuda técnica mejoró la mantenibilidad sin presión de nuevas funcionalidades.
    \item \textit{Documentación como entregable:} Invertir tiempo en documentación técnica y de usuario facilitó la transferencia de conocimiento. El README completo y las guías redujeron consultas post-entrega en 80\%.
    \item \textit{Videos demo efectivos:} Los videos demo de funcionalidades principales fue más efectivo que documentación escrita para stakeholders no técnicos. Se convirtió en la herramienta principal de onboarding.
    \item \textit{Optimización de rendimiento:} Las optimizaciones en áreas críticas mejoraron tiempos de respuesta en 30\%. Identificar y resolver cuellos de botella antes del lanzamiento previno problemas de escalabilidad.
    \item \textit{Cierre ordenado del proyecto:} Tener un sprint dedicado al cierre evitó la sensación de "proyecto inacabado". El equipo pudo celebrar logros y documentar aprendizajes para futuros proyectos.
\end{itemize}



\subsection{Pruebas y Validación}

\subsubsection{Estrategia de Testing}

La estrategia de pruebas del proyecto Irakani Builder se basó en un enfoque pragmático de validación continua durante el desarrollo, combinando pruebas unitarias manuales, verificación de funcionalidades de IA, y validación con usuarios reales del equipo de ventas.

\textbf{Enfoque de Pruebas Implementado:}

\begin{enumerate}
    \item \textbf{Pruebas Unitarias Manuales Durante el Desarrollo:}
    \begin{itemize}
        \item Verificación manual de cada función crítica al momento de implementarla
        \item Pruebas de regresión cuando se modificaban componentes importantes
        \item Validación de endpoints de API mediante herramientas como Postman o Thunder Client
        \item Testing de funciones de transformación de datos (JSON parsing, validaciones)
    \end{itemize}
    
    \item \textbf{Verificación de Funcionalidades de IA:}
    \begin{itemize}
        \item Pruebas iterativas de prompts con AWS Bedrock
        \item Validación de la calidad de código generado por la IA
        \item Verificación de la estructura JSON generada
        \item Testing de diferentes casos de uso (formularios simples, aplicaciones complejas)
        \item Ajuste de parámetros de temperatura y tokens según resultados
    \end{itemize}
    
    \item \textbf{Validación con Usuario Real (Área de Ventas):}
    \begin{itemize}
        \item Colaboración con compañero del área de ventas para pruebas en escenarios reales
        \item Uso de Irakani Builder para crear demos de ventas
        \item Reporte de errores y problemas de usabilidad detectados en uso real
        \item Feedback continuo sobre funcionalidades necesarias
    \end{itemize}
\end{enumerate}

\subsubsection{Proceso de Pruebas Unitarias Manuales}

Durante el desarrollo, se implementó un proceso de verificación continua donde cada funcionalidad se probaba manualmente al momento de su implementación y después de modificaciones importantes.

\textbf{Metodología de Pruebas Unitarias:}

\begin{enumerate}
    \item \textbf{Pruebas Durante el Desarrollo:}
    \begin{itemize}
        \item Al implementar una nueva función, se verificaba su comportamiento con diferentes inputs
        \item Se probaban casos normales, casos límite y casos de error
        \item Se utilizaba \texttt{console.log()} para inspeccionar valores intermedios
        \item Se verificaba el comportamiento en el navegador (DevTools)
    \end{itemize}
    
    \item \textbf{Pruebas de Regresión:}
    \begin{itemize}
        \item Cuando se modificaba un componente importante, se verificaban las funciones dependientes
        \item Se revisaban las funcionalidades relacionadas para detectar efectos secundarios
        \item Se probaban los flujos completos que involucraban el componente modificado
    \end{itemize}
    
    \item \textbf{Pruebas de APIs:}
    \begin{itemize}
        \item Uso de Thunder Client (extensión de VS Code) para probar endpoints
        \item Verificación de respuestas correctas con diferentes parámetros
        \item Validación de manejo de errores (credenciales inválidas, timeouts, etc.)
        \item Pruebas de autenticación con tokens JWT
    \end{itemize}
\end{enumerate}

\textbf{Ejemplo de Verificación Manual de Función Crítica:}

\begin{lstlisting}[ caption={Verificación manual de función de parsing JSON}]
// Funcion a probar: transformar JSON de IA a estructura de componentes
function parseAIResponseToComponents(jsonResponse) {
  try {
    const parsed = JSON.parse(jsonResponse);
    
    // Verificacion manual 1: Estructura basica
    console.log('Estructura recibida:', parsed);
    
    if (!parsed.aplicacion || !parsed.aplicacion.formas) {
      console.error('ERROR: Estructura invalida');
      return null;
    }
    
    // Verificacion manual 2: Transformacion de elementos
    const components = parsed.aplicacion.formas.map(forma => {
      console.log('Procesando forma:', forma.nombre);
      return transformForm(forma);
    });
    
    console.log('Componentes generados:', components.length);
    return components;
    
  } catch (error) {
    console.error('Error en parsing:', error);
    return null;
  }
}

// Prueba manual con diferentes casos:
// Caso 1: JSON valido simple
const test1 = parseAIResponseToComponents(validSimpleJSON);
console.assert(test1 !== null, 'Caso 1 fallo');

// Caso 2: JSON complejo con formas anidadas
const test2 = parseAIResponseToComponents(complexJSON);
console.assert(test2.length > 0, 'Caso 2 fallo');

// Caso 3: JSON malformado (debe manejar error)
const test3 = parseAIResponseToComponents('{invalid json}');
console.assert(test3 === null, 'Caso 3 fallo - no manejo error');
\end{lstlisting}

\textbf{Áreas Críticas Probadas Manualmente:}

\begin{itemize}
    \item \textbf{Autenticación:} Login, logout, renovación de tokens, manejo de sesiones expiradas
    \item \textbf{Generación de IA:} Diferentes tipos de prompts, validación de JSON generado, manejo de errores de Bedrock
    \item \textbf{Editor de Código:} Sincronización entre vista visual y código, guardado automático, validación de JSON
    \item \textbf{Conexión a Bases de Datos:} Conexión a MySQL y SQL Server, ejecución de queries, manejo de timeouts
    \item \textbf{Gestión de Sesiones:} Creación, guardado, recuperación y eliminación de sesiones en Valkey
    \item \textbf{Chat con IA:} Envío de mensajes, streaming de respuestas, aplicación de cambios sugeridos
\end{itemize}


\subsubsection{Verificación de Funcionalidades de IA}

Una parte fundamental del proceso de pruebas fue la verificación iterativa de las funcionalidades de inteligencia artificial, especialmente la generación de código y componentes mediante AWS Bedrock.

\textbf{Proceso de Verificación de IA:}

\begin{enumerate}
    \item \textbf{Pruebas de Prompts:}
    \begin{itemize}
        \item Se probaron diferentes formulaciones de prompts para el mismo objetivo
        \item Se evaluó la calidad del código generado en cada iteración
        \item Se ajustaron los system prompts según los resultados obtenidos
        \item Se documentaron los prompts que generaban mejores resultados
    \end{itemize}
    
    \item \textbf{Validación de Estructura JSON:}
    \begin{itemize}
        \item Verificación manual de que el JSON generado cumpliera con el esquema esperado
        \item Pruebas con diferentes niveles de complejidad (formularios simples vs. aplicaciones complejas)
        \item Validación de campos requeridos (nombre, tipo, propiedades)
        \item Detección de inconsistencias en la estructura generada
    \end{itemize}
    
    \item \textbf{Ajuste de Parámetros de IA:}
    \begin{itemize}
        \item Experimentación con diferentes valores de temperatura (0.2 - 0.7)
        \item Ajuste de maxTokens según complejidad de la tarea
        \item Pruebas con diferentes modelos (Claude Sonnet 4, Claude Haiku)
        \item Optimización de costos vs. calidad de resultados
    \end{itemize}
    
    \item \textbf{Casos de Prueba de IA:}
    \begin{itemize}
        \item Formulario simple de contacto (nombre, email, mensaje)
        \item Formulario de registro con validaciones
        \item Aplicación de gestión de inventario con múltiples formas
        \item Aplicación con listas, perfiles y entidades relacionadas
        \item Generación de código JavaScript para validaciones personalizadas
    \end{itemize}
\end{enumerate}

\textbf{Ejemplo de Verificación de Generación de IA:}

\begin{lstlisting}[caption={Proceso de verificación de generación con IA}]
// Prompt de prueba
const prompt = "Crea un formulario de registro con nombre, email, 
                password y confirmacion de password. El email debe 
                validarse y las passwords deben coincidir.";

// 1. Enviar a Bedrock y recibir respuesta
const response = await bedrockService.generate(prompt);

// 2. Verificacion manual de estructura
console.log('JSON generado:', JSON.stringify(response, null, 2));

// Checklist de verificacion:
// [x] Tiene propiedad 'aplicacion'
// [x] Tiene array 'formas' con al menos 1 elemento
// [x] Forma tiene 4 elementos (nombre, email, password, confirmPassword)
// [x] Email tiene validacion de formato
// [x] Passwords tienen validacion de coincidencia
// [x] Todos los campos tienen 'requerido: true'

// 3. Probar renderizado en el editor
loadJSONIntoEditor(response);

// 4. Verificar vista previa
renderPreview(response);

// 5. Probar funcionalidad de validacion
testValidations(response);

// Resultado: Si todo funciona correctamente, marcar prompt como valido
// Si hay problemas, ajustar system prompt y repetir
\end{lstlisting}

\textbf{Resultados de Verificación de IA:}

Después de múltiples iteraciones de prueba y ajuste, se lograron los siguientes resultados:

\begin{itemize}
    \item \textbf{Tasa de éxito en generación:} Aproximadamente 85-90\% de las generaciones producían JSON válido y funcional
    \item \textbf{Casos que requerían ajuste manual:} 10-15\% necesitaban pequeñas correcciones en el JSON generado
    \item \textbf{Prompts más efectivos:} Los prompts detallados con ejemplos específicos generaban mejores resultados que prompts genéricos
    \item \textbf{Temperatura óptima:} 0.4 demostró ser el mejor balance entre creatividad y consistencia
    \item \textbf{Modelo preferido:} Claude Sonnet 4 generó código de mayor calidad que modelos más económicos
\end{itemize}


\subsubsection{Validación con Usuario del Área de Ventas}

Una parte fundamental del proceso de validación fue la colaboración con un compañero del área de ventas que utilizó Irakani Builder para crear demos reales para clientes potenciales. Esta validación en escenarios reales proporcionó feedback valioso sobre la usabilidad y funcionalidad del sistema.

\textbf{Contexto de la Colaboración:}

\begin{itemize}
    \item \textbf{Usuario validador:} Compañero del área de ventas de Irakani
    \item \textbf{Objetivo:} Crear demos de aplicaciones para presentaciones a clientes
    \item \textbf{Duración:} Aproximadamente 6 semanas (desde Sprint 7 hasta Sprint 10)
    \item \textbf{Frecuencia de uso:} 2-3 veces por semana para crear nuevas demos
    \item \textbf{Comunicación:} Reporte de errores y sugerencias vía Microsoft Teams y reuniones semanales
\end{itemize}

\textbf{Casos de Uso Reales Probados:}

\begin{enumerate}
    \item \textbf{Demo de Sistema de Gestión de Inventario:}
    \begin{itemize}
        \item Formularios de alta de productos
        \item Consultas a base de datos de inventario
        \item Reportes de stock bajo
        \item Resultado: Generación exitosa, requirió ajustes menores en validaciones
    \end{itemize}
    
    \item \textbf{Demo de Aplicación de Registro de Visitas:}
    \begin{itemize}
        \item Formulario de check-in con geolocalización
        \item Captura de firma digital
        \item Sincronización con base de datos central
        \item Resultado: Detectó error en manejo de campos de tipo imagen
    \end{itemize}
    
    \item \textbf{Demo de Sistema de Encuestas:}
    \begin{itemize}
        \item Formularios dinámicos con preguntas condicionales
        \item Diferentes tipos de respuesta (opción múltiple, texto libre, escala)
        \item Visualización de resultados
        \item Resultado: Funcionó correctamente, sugirió mejora en preview de formularios
    \end{itemize}
    
    \item \textbf{Demo de Aplicación de Pedidos:}
    \begin{itemize}
        \item Catálogo de productos con búsqueda
        \item Carrito de compras
        \item Cálculo de totales y descuentos
        \item Resultado: Detectó problema con cálculos en JavaScript generado
    \end{itemize}
\end{enumerate}

\textbf{Errores y Problemas Detectados:}

Durante el uso real de la herramienta, el usuario del área de ventas reportó los siguientes problemas:

\begin{table}[H]
\centering
\caption{Errores Reportados por Usuario de Ventas}
\label{tab:errores_ventas}
\begin{tabular}{|p{1cm}|p{5cm}|p{3cm}|p{3cm}|}
\hline
\textbf{ID} & \textbf{Descripción del Error} & \textbf{Severidad} & \textbf{Estado} \\
\hline
E-01 & Campos de tipo imagen no se guardaban correctamente & Alta & Corregido Sprint 8 \\
\hline
E-02 & Chat de IA no aplicaba cambios en listas existentes & Media & Corregido Sprint 8 \\
\hline
E-03 & Temas oscuros dificultaban lectura en presentaciones & Baja & Corregido Sprint 9 \\
\hline
E-04 & Cálculos con decimales generaban errores de redondeo & Alta & Corregido Sprint 9 \\
\hline
E-05 & Sesiones se perdían al cerrar navegador & Media & Corregido Sprint 9 \\
\hline
E-06 & Preview no mostraba validaciones personalizadas & Baja & Corregido Sprint 10 \\
\hline
E-07 & Exportación de JSON fallaba con aplicaciones grandes & Media & Corregido Sprint 10 \\
\hline
\end{tabular}
\end{table}

\textbf{Feedback Cualitativo:}

El usuario del área de ventas proporcionó el siguiente feedback sobre su experiencia:

\begin{quote}
\textit{``Irakani Builder me ha permitido crear demos personalizadas para cada cliente en cuestión de minutos, algo que antes me tomaba días de coordinación con el equipo de desarrollo. La capacidad de generar aplicaciones con IA y luego ajustarlas manualmente es perfecta para mi flujo de trabajo. Los errores que encontré fueron corregidos rápidamente, y las sugerencias que hice fueron tomadas en cuenta. Ahora puedo llegar a reuniones con clientes con demos funcionales específicas para sus necesidades.''}
\end{quote}

\textbf{Impacto en el Desarrollo:}

La validación con un usuario real del área de ventas tuvo los siguientes impactos positivos en el proyecto:

\begin{itemize}
    \item \textbf{Detección temprana de bugs:} 7 errores críticos y medios fueron detectados antes del lanzamiento oficial
    \item \textbf{Mejora de usabilidad:} Las sugerencias mejoraron la experiencia de usuario para no-desarrolladores
    \item \textbf{Validación de casos de uso:} Confirmó que la herramienta era útil para escenarios reales de negocio
    \item \textbf{Priorización de funcionalidades:} Ayudó a identificar qué características eran más importantes para usuarios finales
    \item \textbf{Confianza en el producto:} El uso exitoso en demos reales validó la viabilidad del proyecto
\end{itemize}

\subsubsection{Resumen del Proceso de Validación}

El proceso de pruebas y validación de Irakani Builder se caracterizó por un enfoque pragmático y continuo, adaptado a las necesidades reales del proyecto y los recursos disponibles.

\textbf{Metodología General:}

\begin{enumerate}
    \item \textbf{Desarrollo Iterativo con Validación Continua:}
    \begin{itemize}
        \item Cada funcionalidad se probaba manualmente al momento de implementarla
        \item Las modificaciones importantes desencadenaban pruebas de regresión
        \item Se utilizaron herramientas de desarrollo (DevTools, Thunder Client) para verificación inmediata
    \end{itemize}
    
    \item \textbf{Verificación Especializada de IA:}
    \begin{itemize}
        \item Pruebas iterativas de prompts y ajuste de parámetros
        \item Validación de calidad del código generado
        \item Optimización del balance costo-calidad
    \end{itemize}
    
    \item \textbf{Validación en Escenarios Reales:}
    \begin{itemize}
        \item Uso de la herramienta por usuario del área de ventas
        \item Detección de errores en casos de uso reales
        \item Feedback continuo para mejoras de usabilidad
    \end{itemize}
\end{enumerate}

\textbf{Resultados Cuantitativos:}

\begin{table}[H]
\centering
\caption{Resumen de Resultados de Validación}
\label{tab:resumen_validacion}
\begin{tabular}{|l|c|}
\hline
\textbf{Métrica} & \textbf{Resultado} \\
\hline
Errores críticos detectados y corregidos & 7 \\
\hline
Errores menores detectados y corregidos & 12 \\
\hline
Tasa de éxito en generación de IA & 85-90\% \\
\hline
Casos de uso reales probados & 4 \\
\hline
Sugerencias de mejora implementadas & 5 \\
\hline
Tiempo promedio de corrección de bugs & 2-3 días \\
\hline
\end{tabular}
\end{table}

\textbf{Lecciones Aprendidas:}

\begin{itemize}
    \item \textbf{Validación temprana con usuarios reales:} La colaboración con el área de ventas permitió detectar problemas que no se habrían identificado solo con pruebas técnicas
    \item \textbf{Importancia de pruebas de regresión:} Verificar funcionalidades relacionadas después de cambios previno la introducción de nuevos bugs
    \item \textbf{Iteración en prompts de IA:} La calidad de las generaciones mejoró significativamente con ajustes iterativos basados en resultados reales
    \item \textbf{Feedback continuo:} El canal abierto de comunicación con el usuario validador permitió correcciones rápidas y mejoras incrementales
    \item \textbf{Documentación de casos de prueba:} Mantener registro de los casos probados facilitó las pruebas de regresión y la detección de patrones de error
\end{itemize}

\subsection{Despliegue y Puesta en Producción}

\subsubsection{Pipeline CI/CD}

El pipeline de integración y despliegue continuo se implementó utilizando AWS CodePipeline, con las siguientes etapas:

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    node distance=1.2cm,
    stage/.style={rectangle, rounded corners, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=blue!20, font=\small},
    arrow/.style={thick, ->, >=stealth}
]

% Etapas del pipeline
\node (source) [stage] {1. Source\\Bitbucket};
\node (build) [stage, below=of source] {2. Build\\Frontend + Backend};
\node (deploy) [stage, below=of build] {3. Deploy\\EC2 + Docker};
\node (approval) [stage, below=of deploy, fill=yellow!30] {4. Manual Approval\\Product Owner};
\node (ami) [stage, below=of approval] {5. Create AMI\\Snapshot};
\node (asg) [stage, below=of ami] {6. Update ASG\\Rolling Update};
\node (prod) [stage, below=of asg, fill=green!30] {Producción\\Disponible};

% Flechas
\draw [arrow] (source) -- node[anchor=west, font=\tiny] {10-15s} (build);
\draw [arrow] (build) -- node[anchor=west, font=\tiny] {3-5min} (deploy);
\draw [arrow] (deploy) -- node[anchor=west, font=\tiny] {1-2min} (approval);
\draw [arrow] (approval) -- node[anchor=west, font=\tiny] {Variable} (ami);
\draw [arrow] (ami) -- node[anchor=west, font=\tiny] {5-8min} (asg);
\draw [arrow] (asg) -- node[anchor=west, font=\tiny] {5-10min} (prod);

% Anotaciones laterales
\node[anchor=west, font=\tiny, text width=3cm] at (4, 0) {Webhook automático\\desde Git};
\node[anchor=west, font=\tiny, text width=3cm] at (4, -1.2) {Pruebas unitarias\\Imágenes Docker};
\node[anchor=west, font=\tiny, text width=3cm] at (4, -2.4) {Health checks\\Validación};
\node[anchor=west, font=\tiny, text width=3cm] at (4, -3.6) {Revisión humana\\Punto de control};
\node[anchor=west, font=\tiny, text width=3cm] at (4, -4.8) {Versionamiento\\Backup};
\node[anchor=west, font=\tiny, text width=3cm] at (4, -6.0) {Zero downtime\\Escalable};

\end{tikzpicture}
\caption{Diagrama del Pipeline CI/CD de Irakani Builder}
\label{fig:pipeline_cicd}
\end{figure}

\textbf{Etapa 1: Source}
\begin{itemize}
    \item Trigger: Commit a rama main en Bitbucket
    \item Acción: Descarga de código fuente
    \item Webhook configurado para ejecución automática
\end{itemize}

\textbf{Etapa 2: Build}
\begin{itemize}
    \item CodeBuild Project: BuildFrontend
    \begin{itemize}
        \item Compilación de React con Vite
        \item Ejecución de pruebas unitarias
        \item Generación de bundle optimizado
        \item Creación de imagen Docker
        \item Push a ECR (Elastic Container Registry)
    \end{itemize}
    \item CodeBuild Project: BuildBackend
    \begin{itemize}
        \item Instalación de dependencias Node.js
        \item Ejecución de pruebas unitarias
        \item Creación de imagen Docker
        \item Push a ECR
    \end{itemize}
\end{itemize}

\textbf{Etapa 3: Deploy}
\begin{itemize}
    \item CodeBuild Project: DeployToEC2
    \item Acciones:
    \begin{itemize}
        \item Pull de imágenes desde ECR
        \item Despliegue con Docker Compose
        \item Actualización de configuraciones
        \item Health checks de servicios
    \end{itemize}
\end{itemize}


\textbf{Etapa 4: Approval}
\begin{itemize}
    \item Tipo: Manual Approval
    \item Responsable: Product Owner
    \item Criterios: Validación de funcionalidades en staging
    \item Notificación: Email automático
\end{itemize}

\textbf{Etapa 5: CreateAMI}
\begin{itemize}
    \item CodeBuild Project: CreateAMI
    \item Acciones:
    \begin{itemize}
        \item Creación de Amazon Machine Image (AMI)
        \item Snapshot del estado actual de producción
        \item Versionamiento de AMI
        \item Registro en Systems Manager Parameter Store
    \end{itemize}
\end{itemize}

\textbf{Etapa 6: UpdateASG}
\begin{itemize}
    \item CodeBuild Project: UpdateAutoScalingGroup
    \item Acciones:
    \begin{itemize}
        \item Actualización de Launch Template con nueva AMI
        \item Rolling update del Auto Scaling Group
        \item Verificación de health checks
        \item Rollback automático en caso de fallo
    \end{itemize}
\end{itemize}

\textbf{Artefactos Generados:}
\begin{itemize}
    \item Imágenes Docker en ECR
    \item AMIs versionadas
    \item Logs de compilación en S3
    \item Reportes de pruebas
\end{itemize}

\textbf{Tiempos de Ejecución del Pipeline:}

El pipeline CI/CD completo se ejecuta en tiempos predecibles, permitiendo despliegues rápidos y confiables:

\begin{table}[H]
\centering
\caption{Tiempos Promedio por Etapa del Pipeline CI/CD}
\label{tab:tiempos_pipeline}
\begin{tabular}{|l|c|c|}
\hline
\textbf{Etapa} & \textbf{Tiempo Promedio} & \textbf{Tiempo Máximo} \\
\hline
Source & 10-15 segundos & 30 segundos \\
\hline
Build Frontend & 2-3 minutos & 5 minutos \\
\hline
Build Backend & 1-2 minutos & 4 minutos \\
\hline
Deploy to EC2 & 1-2 minutos & 3 minutos \\
\hline
Manual Approval & Variable (humano) & N/A \\
\hline
Create AMI & 5-8 minutos & 12 minutos \\
\hline
Update ASG & 5-10 minutos & 15 minutos \\
\hline
\textbf{Total (sin approval)} & \textbf{14-25 minutos} & \textbf{39 minutos} \\
\hline
\textbf{Total (con approval)} & \textbf{20-35 minutos} & \textbf{50+ minutos} \\
\hline
\end{tabular}
\end{table}

\textbf{Frecuencia de Despliegues:}
\begin{itemize}
    \item Despliegues a staging: 3-5 veces por día durante desarrollo activo
    \item Despliegues a producción: 2-3 veces por semana
    \item Hotfixes críticos: <1 hora desde detección hasta producción
\end{itemize}

\textbf{Configuración de Docker Compose:}

El despliegue en EC2 utiliza Docker Compose para orquestar los contenedores de frontend y backend:

\begin{lstlisting}[language=yaml, caption={docker-compose.yml para producción}]
version: '3.8'

services:
  frontend:
    image: [ECR_ENDPOINT_CENSURADO]/
           irakani-builder-frontend-ci-cd:latest
    container_name: irakani-builder-frontend
    ports:
      - "[PUERTO_CENSURADO]:[PUERTO_CENSURADO]"
    environment:
      - NODE_ENV=production
      - VITE_API_URL=[URL_BACKEND_LOCAL]
      - VITE_USER_POOL_ID=${COGNITO_USER_POOL_ID}
      - VITE_USER_POOL_CLIENT_ID=${COGNITO_CLIENT_ID}
    restart: unless-stopped
    networks:
      - irakani-network
    healthcheck:
      test: ["CMD", "curl", "-f", "[URL_FRONTEND_LOCAL]"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  backend:
    image: [ECR_ENDPOINT_CENSURADO]/
           irakani-builder-backend-ci-cd:latest
    container_name: irakani-builder-backend
    ports:
      - "[PUERTO_CENSURADO]:[PUERTO_CENSURADO]"
    environment:
      - NODE_ENV=production
      - AWS_REGION=[REGIÓN_AWS]
      - VALKEY_HOST=${VALKEY_ENDPOINT}
      - VALKEY_PORT=[PUERTO_CENSURADO]
      - DB_HOST=${RDS_ENDPOINT}
      - DB_PORT=[PUERTO_CENSURADO]
      - JWT_SECRET=${JWT_SECRET}
    restart: unless-stopped
    networks:
      - irakani-network
    depends_on:
      - frontend
    healthcheck:
      test: ["CMD", "curl", "-f", "[URL_BACKEND_LOCAL]/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

networks:
  irakani-network:
    driver: bridge
\end{lstlisting}


\subsubsection{Infraestructura AWS}

La infraestructura de producción se desplegó en AWS utilizando los siguientes servicios:

\textbf{Cómputo:}
\begin{itemize}
    \item \textbf{EC2 Instances:} t3.medium para frontend y backend
    \item \textbf{Auto Scaling Group:} 2-4 instancias según demanda
    \item \textbf{Application Load Balancer:} Distribución de tráfico
    \item \textbf{Target Groups:} Health checks cada 30 segundos
\end{itemize}

\textbf{Almacenamiento:}
\begin{itemize}
    \item \textbf{S3 Buckets:}
    \begin{itemize}
        \item irakani-builder-artifacts: Artefactos de CI/CD
        \item irakani-builder-apps: Aplicaciones generadas
        \item irakani-builder-icons: Iconos generados por IA
    \end{itemize}
    \item \textbf{EBS Volumes:} 30GB gp3 por instancia EC2
\end{itemize}

\textbf{Base de Datos y Caché:}
\begin{itemize}
    \item \textbf{RDS} Base de datos principal (db.t3.micro)
    \item \textbf{ElastiCache (Valkey):} Cluster de caché (cache.t3.micro)
    \item \textbf{DynamoDB:} Metadatos de aplicaciones y logs de uso
\end{itemize}

\textbf{Servicios de IA:}
\begin{itemize}
    \item \textbf{AWS Bedrock:} Claude 3.5 Sonnet, Titan Image Generator
    \item \textbf{AWS Cognito:} User Pool para autenticación
\end{itemize}


\textbf{Redes y Seguridad:}
\begin{itemize}
    \item \textbf{VPC:} Red privada virtual con subnets públicas y privadas
    \item \textbf{Security Groups:}
    \begin{itemize}
        \item ALB-SG: Puertos [PUERTO_CENSURADO], [PUERTO_CENSURADO] abiertos a internet
        \item EC2-SG: Puerto [PUERTO_CENSURADO] (frontend), 5000 (backend) desde ALB
        \item RDS-SG: Puerto [PUERTO_CENSURADO] solo desde EC2-SG
        \item Cache-SG: Puerto [PUERTO_CENSURADO] solo desde EC2-SG
    \end{itemize}
    \item \textbf{IAM Roles:}
    \begin{itemize}
        \item EC2-Role: Acceso a S3, Bedrock, DynamoDB
        \item CodeBuild-Role: Acceso a ECR, S3, EC2
        \item Lambda-Role: Acceso a Step Functions, Bedrock
    \end{itemize}
    \item \textbf{ACM Certificates:} SSL/TLS para HTTPS
\end{itemize}

\textbf{Orquestación:}
\begin{itemize}
    \item \textbf{Step Functions:} Workflows de generación de aplicaciones
    \item \textbf{Lambda Functions:} Procesamiento asíncrono de prompts
    \item \textbf{EventBridge:} Triggers para tareas programadas
\end{itemize}

\textbf{Costos Estimados Mensuales:}
\begin{itemize}
    \item EC2 + ALB: [COSTO CENSURADO]
    \item RDS: [COSTO CENSURADO]
    \item ElastiCache: [COSTO CENSURADO]
    \item S3 + Data Transfer: [COSTO CENSURADO]
    \item Bedrock (uso variable): [COSTO CENSURADO]
    \item Total estimado: [COSTO CENSURADO]/mes
\end{itemize}


\subsubsection{Monitoreo y Observabilidad}

El sistema de monitoreo se implementó utilizando una combinación de servicios de AWS para garantizar la disponibilidad, rendimiento y trazabilidad del uso de recursos de la plataforma:

\textbf{Registro de Uso de IA en DynamoDB:}

El sistema implementa un registro completo de todas las operaciones de IA en una tabla de DynamoDB llamada \texttt{IrakaniBuilderUsageLogs}, que permite trazabilidad detallada del consumo de modelos de AWS Bedrock por usuario y contexto.

\textbf{Estructura de la Tabla DynamoDB:}

\begin{table}[H]
\centering
\caption{Esquema de la tabla IrakaniBuilderUsageLogs}
\label{tab:dynamodb_usage_logs}
\begin{tabular}{|l|l|p{6cm}|}
\hline
\textbf{Campo} & \textbf{Tipo} & \textbf{Descripción} \\
\hline
logId (PK) & String & ID único del registro \\
\hline
userId & String & Username del usuario (Cognito) \\
\hline
timestamp & String & Fecha y hora ISO8601 \\
\hline
model & String & Modelo utilizado (claude-sonnet-4, etc.) \\
\hline
schema & String & Esquema de trabajo (espacio Irakani) \\
\hline
context & String & Contexto de la operación \\
\hline
inputTokens & Number & Tokens de entrada consumidos \\
\hline
outputTokens & Number & Tokens de salida generados \\
\hline
totalTokens & Number & Total de tokens (input + output) \\
\hline
imageCount & Number & Número de imágenes generadas \\
\hline
cost & Number & Costo calculado en USD \\
\hline
sessionId & String & ID de sesión (opcional) \\
\hline
\end{tabular}
\end{table}

\textbf{Consultas de Uso Implementadas:}

El sistema permite consultar el uso de IA mediante queries a DynamoDB:

\begin{lstlisting}[language=bash, caption={Consultar uso por usuario}]
# Obtener todos los registros de un usuario
aws dynamodb query \
  --table-name IrakaniBuilderUsageLogs \
  --key-condition-expression "userId = :uid" \
  --expression-attribute-values '{":uid":{"S":"johndoe"}}' \
  --scan-index-forward false \
  --limit 100

# Calcular costo total por usuario en un periodo
aws dynamodb query \
  --table-name IrakaniBuilderUsageLogs \
  --key-condition-expression "userId = :uid AND timestamp BETWEEN :start AND :end" \
  --expression-attribute-values '{
    ":uid":{"S":"johndoe"},
    ":start":{"S":"2025-11-01T00:00:00Z"},
    ":end":{"S":"2025-11-30T23:59:59Z"}
  }' \
  --projection-expression "cost, model, timestamp"
\end{lstlisting}

\textbf{Dashboard de Visualización de Métricas:}

Se implementó un dashboard web integrado en el SpaceMenu del frontend que permite a los usuarios visualizar sus métricas de uso de IA en tiempo real:

\textbf{Componente UsageDashboard:}

\begin{lstlisting}[caption={Componente de dashboard de uso}]
// src/components/UsageDashboard/UsageDashboard.tsx
import React, { useState, useEffect } from 'react';
import { usageService } from '../../services/usageService';

export const UsageDashboard: React.FC = ({ userId }) => {
  const [usageData, setUsageData] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    loadUsageData();
  }, [userId]);
  
  const loadUsageData = async () => {
    try {
      const data = await usageService.getUserUsage(userId);
      setUsageData(data);
    } catch (error) {
      console.error('Error cargando datos de uso:', error);
    } finally {
      setLoading(false);
    }
  };
  
  if (loading) return <div>Cargando metricas...</div>;
  
  return (
    <div className="usage-dashboard">
      <h3>Uso de IA - Ultimos 30 dias</h3>
      
      <div className="metrics-grid">
        <div className="metric-card">
          <h4>Tokens Totales</h4>
          <p className="metric-value">
            {usageData.totalTokens.toLocaleString()}
          </p>
        </div>
        
        <div className="metric-card">
          <h4>Costo Total</h4>
          <p className="metric-value">
            ${usageData.totalCost.toFixed(2)}
          </p>
        </div>
        
        <div className="metric-card">
          <h4>Operaciones</h4>
          <p className="metric-value">
            {usageData.operationCount}
          </p>
        </div>
        
        <div className="metric-card">
          <h4>Imagenes Generadas</h4>
          <p className="metric-value">
            {usageData.imageCount}
          </p>
        </div>
      </div>
      
      <div className="usage-by-model">
        <h4>Uso por Modelo</h4>
        <table>
          <thead>
            <tr>
              <th>Modelo</th>
              <th>Operaciones</th>
              <th>Tokens</th>
              <th>Costo</th>
            </tr>
          </thead>
          <tbody>
            {usageData.byModel.map(model => (
              <tr key={model.name}>
                <td>{model.name}</td>
                <td>{model.count}</td>
                <td>{model.tokens.toLocaleString()}</td>
                <td>${model.cost.toFixed(4)}</td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
      
      <div className="usage-chart">
        <h4>Tendencia de Uso</h4>
        {/* Grafico de lineas con uso diario */}
      </div>
    </div>
  );
};
\end{lstlisting}

\textbf{Características del Dashboard:}
\begin{itemize}
    \item Visualización de tokens totales consumidos
    \item Costo acumulado en USD
    \item Número de operaciones realizadas
    \item Desglose por modelo de IA utilizado
    \item Gráfico de tendencia de uso diario
    \item Filtros por rango de fechas
    \item Exportación de reportes en CSV
\end{itemize}

\textbf{Acceso a Logs de la Instancia EC2:}

Para monitorear los logs de la aplicación en tiempo real, se utilizan comandos SSH y Docker directamente en la instancia EC2:

\textbf{Conexión a la Instancia:}

\begin{lstlisting}[language=bash, caption={Conectarse a la instancia EC2}]
# Opcion 1: SSH tradicional (requiere key pair)
ssh -i ~/.ssh/irakani-builder-key.pem ec2-user@<instance-public-ip>

# Opcion 2: AWS Systems Manager Session Manager (recomendado)
aws ssm start-session --target <instance-id>

# Ejemplo con instance ID especifico
aws ssm start-session --target i-0123456789abcdef0
\end{lstlisting}

\textbf{Comandos para Ver Logs:}

Una vez conectado a la instancia, se pueden consultar los logs de los contenedores Docker:

\begin{lstlisting}[language=bash, caption={Comandos de logs en la instancia}]
# Ver logs de todos los servicios
cd /opt/irakani-builder
docker-compose logs

# Ver logs del backend en tiempo real
docker-compose logs -f backend

# Ver logs del frontend en tiempo real
docker-compose logs -f frontend

# Ver ultimas 100 lineas del backend
docker-compose logs --tail=100 backend

# Ver logs con timestamps
docker-compose logs -t backend

# Filtrar logs por patron (ejemplo: errores)
docker-compose logs backend | grep -i error

# Ver logs de un contenedor especifico por nombre
docker logs irakani-builder-backend

# Ver logs con seguimiento continuo
docker logs -f irakani-builder-backend

# Ver logs desde una fecha especifica
docker logs --since 2025-11-26T10:00:00 irakani-builder-backend

# Ver logs hasta una fecha especifica
docker logs --until 2025-11-26T12:00:00 irakani-builder-backend
\end{lstlisting}

\textbf{Monitoreo de Estado de Contenedores:}

\begin{lstlisting}[language=bash, caption={Verificar estado de servicios}]
# Ver estado de todos los contenedores
docker-compose ps

# Ver uso de recursos de contenedores
docker stats

# Ver uso de recursos de un contenedor especifico
docker stats irakani-builder-backend

# Inspeccionar configuracion de un contenedor
docker inspect irakani-builder-backend

# Ver health checks de contenedores
docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
\end{lstlisting}

\textbf{Análisis de Logs para Debugging:}

\begin{lstlisting}[language=bash, caption={Comandos de análisis de logs}]
# Contar errores en logs del backend
docker-compose logs backend | grep -c "ERROR"

# Ver errores unicos
docker-compose logs backend | grep "ERROR" | sort | uniq

# Buscar logs de un usuario especifico
docker-compose logs backend | grep "userId: johndoe"

# Ver logs de operaciones de IA
docker-compose logs backend | grep "Bedrock"

# Exportar logs a archivo para analisis
docker-compose logs backend > backend-logs-$(date +%Y%m%d).log

# Ver logs de conexiones a base de datos
docker-compose logs backend | grep "database"

# Monitorear latencia de requests
docker-compose logs backend | grep "response time"
\end{lstlisting}

\textbf{Rotación y Gestión de Logs:}

Los logs de Docker se configuran con rotación automática para evitar llenar el disco:

\begin{lstlisting}[language=yaml, caption={Configuración de logging en docker-compose.yml}]
services:
  backend:
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
        
  frontend:
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
\end{lstlisting}

Esta configuración mantiene un máximo de 3 archivos de log de 10MB cada uno por servicio, rotando automáticamente cuando se alcanza el límite.

\textbf{Estrategia de Backup:}
\begin{itemize}
    \item \textbf{RDS:} Snapshots automáticos diarios, retención 7 días
    \item \textbf{S3:} Versionamiento habilitado, lifecycle policies
    \item \textbf{AMIs:} Creación automática en cada despliegue
    \item \textbf{DynamoDB:} Point-in-time recovery habilitado
\end{itemize}

\textbf{Plan de Recuperación ante Desastres:}
\begin{itemize}
    \item RTO (Recovery Time Objective): 2 horas
    \item RPO (Recovery Point Objective): 24 horas
    \item Procedimiento de rollback documentado
    \item Restauración desde última AMI funcional
    \item Pruebas de recuperación trimestrales
\end{itemize}

\textbf{Métricas de Disponibilidad Objetivo:}
\begin{itemize}
    \item Uptime: 99.5\% (SLA interno)
    \item MTTR (Mean Time To Repair): <2 horas
    \item MTBF (Mean Time Between Failures): >720 horas
\end{itemize}

\subsubsection{Manejo de Incidentes y Corrección de Errores}

Durante el desarrollo y operación de Irakani Builder, se implementó un proceso ágil para el manejo de incidentes y corrección de errores en producción:

\textbf{Proceso de Detección y Corrección:}

\begin{enumerate}
    \item \textbf{Detección del Problema:}
    \begin{itemize}
        \item Monitoreo de logs en tiempo real mediante comandos SSH
        \item Revisión del dashboard de métricas de uso en DynamoDB
        \item Reportes de usuarios del área de ventas o equipo interno
        \item Verificación manual de funcionalidades críticas
    \end{itemize}
    
    \item \textbf{Evaluación de Severidad:}
    \begin{itemize}
        \item \textbf{Crítico:} Afecta funcionalidad principal (generación de IA, autenticación)
        \item \textbf{Alto:} Afecta funcionalidad secundaria (guardado de sesiones, temas)
        \item \textbf{Medio:} Problemas de UX o rendimiento no bloqueantes
        \item \textbf{Bajo:} Mejoras cosméticas o sugerencias de usuarios
    \end{itemize}
    
    \item \textbf{Corrección Inmediata:}
    \begin{itemize}
        \item Para errores críticos: corrección en rama \texttt{FIX/}
        \item Pruebas manuales locales de la corrección
        \item Commit y push a Bitbucket
        \item Pipeline CI/CD despliega automáticamente (60-80 minutos)
        \item Verificación en producción mediante logs y pruebas manuales
    \end{itemize}
    
    \item \textbf{Documentación del Incidente:}
    \begin{itemize}
        \item Registro en Jira con descripción del problema
        \item Documentación de la causa raíz identificada
        \item Pasos de reproducción del error
        \item Solución implementada y tiempo de resolución
    \end{itemize}
\end{enumerate}

\textbf{Comandos de Diagnóstico Utilizados:}

Cuando se detecta un problema en producción, se utilizan los siguientes comandos para diagnosticar:

\begin{lstlisting}[language=bash, caption={Comandos de diagnóstico en producción}]
# 1. Conectarse a la instancia
aws ssm start-session --target <instance-id>

# 2. Ver logs recientes del backend
cd /opt/irakani-builder
docker-compose logs --tail=200 backend

# 3. Buscar errores especificos
docker-compose logs backend | grep -i "error" | tail -50

# 4. Verificar estado de contenedores
docker-compose ps

# 5. Ver uso de recursos
docker stats --no-stream

# 6. Reiniciar servicio si es necesario
docker-compose restart backend

# 7. Ver logs en tiempo real para monitorear
docker-compose logs -f backend
\end{lstlisting}

\textbf{Proceso de FIX:}

Para correcciones urgentes, se sigue un proceso simplificado:

\begin{lstlisting}[language=bash, caption={Flujo de FIX}]
# 1. Crear rama de FIX desde main
git checkout main
git pull origin main
git checkout -b FIX/fix-jwt-validation

# 2. Realizar la correccion
# ... editar archivos necesarios ...

# 3. Probar localmente
npm run test
npm run build

# 4. Commit y push
git add .
git commit -m "FIX: Corregir validacion de JWT en middleware"
git push origin FIX/fix-jwt-validation

# 5. Merge a main (o crear PR rapido)
git checkout main
git merge FIX/fix-jwt-validation
git push origin main

# 6. Pipeline CI/CD despliega automaticamente
# Monitorear en CodePipeline: 
# [CONSOLA_AWS_CENSURADA]
\end{lstlisting}

\textbf{Ejemplos de Incidentes Resueltos:}

Durante el desarrollo y operación del proyecto, se resolvieron varios incidentes:

\begin{table}[H]
\centering
\caption{Incidentes Resueltos en Producción}
\label{tab:incidentes_resueltos}
\begin{tabular}{|p{2cm}|p{4cm}|p{2cm}|p{3cm}|}
\hline
\textbf{Sprint} & \textbf{Problema} & \textbf{Severidad} & \textbf{Tiempo de Resolución} \\
\hline
Sprint 8 & Error en validación de JWT causaba logout inesperado & Crítico & 45 minutos \\
\hline
Sprint 8 & Campos de imagen no se guardaban en S3 & Alto & 2 horas \\
\hline
Sprint 9 & Cálculos con decimales generaban errores de redondeo & Alto & 1.5 horas \\
\hline
Sprint 9 & Sesiones se perdían al cerrar navegador & Medio & 3 horas \\
\hline
Sprint 10 & Preview no mostraba validaciones personalizadas & Medio & 1 hora \\
\hline
Sprint 10 & Exportación de JSON fallaba con apps grandes & Alto & 2.5 horas \\
\hline
\end{tabular}
\end{table}

\textbf{Estrategia de Prevención:}

Para minimizar incidentes futuros, se implementaron las siguientes prácticas:

\begin{itemize}
    \item \textbf{Pruebas manuales exhaustivas:} Verificación de funcionalidades críticas antes de cada despliegue
    \item \textbf{Validación con usuario real:} Colaboración con área de ventas para detectar problemas en escenarios reales
    \item \textbf{Monitoreo continuo:} Revisión diaria de logs y métricas de uso
    \item \textbf{Documentación de errores comunes:} Registro de problemas frecuentes y sus soluciones
    \item \textbf{Comunicación rápida:} Canal de Slack para reportes inmediatos de problemas
\end{itemize}

\textbf{Tiempo Promedio de Resolución:}

\begin{itemize}
    \item Errores críticos: 60-120 minutos (detección + corrección + despliegue)
    \item Errores altos: 1-3 horas
    \item Errores medios: 2-4 horas
    \item Mejoras y errores bajos: Se agrupan para siguiente sprint
\end{itemize}
